
<!DOCTYPE html>
<html lang="en">
  <head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="IronHack MADRID - iOS Development">
<meta name="keywords" content="Objective-c, Cocoa, Xcode, Ironhack, Development">
<meta name="author" content="Rafa Paradela">
<title>Apuntes del IronHack - iOS Development 2014</title>
<link href="assets/bootstrap.min.css" rel="stylesheet">
<link href="assets/docs.min.css" rel="stylesheet">

<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
<link href="assets/theme.css" rel="stylesheet">

<!--[if lt IE 9]><script src="../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
  </head>
  <body>
    <a class="sr-only" href="#content">Skip to main content</a>

    <!-- Docs master nav -->
  <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../" class="navbar-brand">IronHack - iOS Development</a>
    </div>
	
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <!--
	  <ul class="nav navbar-nav">
        <li>
          <a href="../getting-started">Getting started</a>
        </li>
        <li>
          <a href="../css">CSS</a>
        </li>
        <li>
          <a href="../components">Components</a>
        </li>
        <li>
          <a href="../javascript">JavaScript</a>
        </li>
        <li class="active">
          <a href="../customize">Customize</a>
        </li>
      </ul>
		 -->
      <ul class="nav navbar-nav navbar-right">
        <li><a href="https://twitter.com/rafaparadela">YO</a></li>
        <li><a href="http://www.ironhack.com/es/">Iron Hack</a></li>
      </ul>
    </nav>
	
	
	
  </div>
</header>

    <div class="container bs-docs-container">

      <div class="row">
		  
		  
        <div class="col-md-2">
          <div class="bs-docs-sidebar hidden-print" role="complementary">
            <ul class="nav bs-docs-sidenav">
              
				<li><a href="#w01">Semana 1</a></li>
				<li><a href="#w02">Semana 2</a></li>
				<li><a href="#w03">Semana 3</a></li>
				<li><a href="#w04">Semana 4</a></li>
              
            </ul>
			
            <a class="back-to-top" href="#top">
              Back to top
            </a>
			
			<div id="social">
				<div class="twitter">
					<a href="https://twitter.com/share" class="twitter-share-button" data-via="rafaparadela">Tweet</a>
					<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
				</div>
			</div>
          </div>
        </div>
		
        <div class="col-md-10" role="main">
          <!-- Customizer form -->

			  <div class="bs-docs-section" id="w01-section">
				  <h1 id="w01" class="page-header">Semana 1</h1>
				  
				  <!-- &&&&&& -->

<h3>Xcode</h3>

<p>Xcode no es solo un IDE más, es una herramienta compleja.</p>

<p>Para ilustrar el repaso por los conceptos más básicos de Xcode, hacemos un <em>Hello World</em> en el que simplemente imprimimos <code>Hello World</code> en la consola. Para no convertir este artículo en un tutorial de Xcode 5, pongo un enlace hacia un <a href="http://codewithchris.com/xcode-tutorial/">Tutorial de Xcode</a>, un tutorial de <a href="http://codewithchris.com/first-xcode-project/">Cómo crear el primer proyecto en Xcode</a> y listo algunas anotaciones que me parecen interensantes:</p>

<ul>
<li>Cuando se crea un proyecto en Xcode, te da la posibilidad de especificar un <code>Class Prefix</code>. Digamos que esto sustituye el sistema de paquetes de otros lenguajes y entornos, y sirve para evitar que existan clases con el mismo nombre. Algunos ejemplos de prefijos de clase archiconocidos pueden ser NS, UI y CF.</li>
<li>Un proyecto Xcode escrito en Objective-c no deja de ser un programa en C supervitaminado. Por tanto el punto de entrada es la función <code>main</code>, que Xcode coloca <em>MyProject >> Supporting FIles >> main.m</em>. El contenido por defecto de esta función en este tipo de proyectos es la llamada a UIApplicationMain (para iniciar el ciclo de eventos de la aplicación). Lo encapsula en un bloque <code>@autoreleasepool</code> que básicamente sirve para liberar la memoria tras la ejecución.</li>
<li>El delegado de la aplicación es una clase que podemos considerar como la puerta para que la aplicación se comunique con el dispositivo. Entre sus métodos, el más importante es <code>didFinishLaunchingWithOptions</code> que avisa cuando la aplicación se abre.</li>
<li>En Xcode el uso de los <em>Targets</em> es un sistema para organizar el proceso de compilación del proyecto. Se pueden añadir pasos a los que por defecto se llevan a cabo cuando se construye la app, que se <em>precompila -> compila -> enlaza -> empaqueta</em>.</li>
<li>El uso de esquemas, también es útil para manipular la ejecución. Por ejemplo es donde habría que definir los argumentos de entrada.</li>
</ul>


<h3>Un vistazo rápido a C</h3>

<p>Es importante recordar algunos conceptos del "abuelo" C, para ello os recomiendo echar vistazo a algún tutorial, por ejemplo <a href="http://www.cprogramming.com/tutorial/c-tutorial.html">este</a>. Nosotros creamos un proyecto de C en Xcode y jugamos un poco con los tipos de variables, la declaración y definición de funciones, con los argumentos de entrada, etc. Algunas anotaciones que merece la pena recordar:</p>

<ul>
<li>Podemos definir nuestros propios tipos de variables con typedef, ejemplo: <code>typedef unsigned int NSUinteger;</code></li>
<li>Con <code>sizeof</code> podemos saber el tamaño que ocupa un tipo en memoria.</li>
<li>Los archivos <em>.h</em> no se meten en el target porque no se compilan.</li>
<li>Es importante recordar la visibilidad de las funciones. Si declaras una función en el <em>.h</em>, se podrán invocar dichas funciones importando la cabecera, sin embargo, si se declara y define una función en el <em>.c</em> se considera una función privada, útil en el ámbito del módulo.</li>
<li>Es posible declarar una variable en el ambito del módulo pero solo visible en la función donde se define. En el siguiente ejemplo <code>sequence</code> se incrementará en cada llamada, <code>next_in_sequence()</code> puede ser una función publica pero quien la llame no pude modificar el valor de <code>sequence</code>:</li>
</ul>


<pre><code>NSUinteger next_in_sequence(){
    static NSUinteger sequence = 0;
    sequence ++;
    return sequence;
}
</code></pre>

<h3>Primera toma de contacto con Objective-c</h3>

<p>Para ir metiéndonos en "manteca", creamos un nuevo proyecto llamado <a href="https://github.com/rafaparadela/iron-hack-week1-beer"><em>Beers</em></a> y que nos servirá durante toda la semana como proyecto de pruebas.</p>

<p>Creamos una clase llamada <em>Beer</em> que nos servirá de ejemplo para ilustrar como se definen las variables de la clase, de la instancia, los método privados, públicos, etc.</p>

<p>En <em>Beer.h</em> (interfaz de la clase) vemos que es una clase que extiende a NSObject <code>@interface Beer : NSObject</code>, y por tanto hereda ciertos métodos propios de cualquier objeto. Vamos a declarar varias variables de instancia, por tanto en la interfaz:</p>

<pre><code>@private
    NSString *name;
    NSString *color;
    NSUInteger grade;
}
</code></pre>

<p>Una variable <em>name</em> de tipo <code>NSString</code> que representará el nombre de la cerveza, una variable <em>color</em> de tipo <code>NSString</code> que representará el color de la cerveza y una variable <em>grade</em> del tipo <code>NSUInteger</code> que representará la graduación de alcohol. Los asteriscos de <em>name</em> y <em>color</em> denotan que realmente dichas variables son punteros, que guardarán la dirección de memoria (<em>heap</em>) donde se almacenará el contenido del objeto <code>NSString</code>. Sin embargo <em>grade</em>, al ser un <code>NSUInteger</code> o sea un entero sin signo no es más que un tipo primario que puede ser guardado localmente (<em>stack</em>).</p>

<h5>Setter &amp; Getter</h5>

<p>Es poco recomendable leer y escribir las variables de instancias accediendo directamente con el operador <code>-&gt;</code> de esta forma <code>cerveza-&gt;name = @"Mahou";</code>. Es más común implementar los métodos que leerán y escribirán estas variables, los getter y los setters. De esta manera tendremos varias vantajas como mayor control en la inicialización poniendo condiciones por ejemplo, no se reserva memoria hasta que se llame al método, omitir el setter impidiendo que sea escrita desde fuera, etc.</p>

<p>Por convenio el getter se nombran igual que la variable que devuelve y los setters se nombran igual que la variable pero con el prefijo <em>set</em>.</p>

<pre><code>- (NSString *) name;
- (void) setName: (NSString * )newName;

- (NSString *) color;
- (void) setColor: (NSString * )newColor;

- (NSUInteger) grade;
- (void) setGrade: (NSUInteger)newGrade;
</code></pre>

<p>En Beer.m la implemetación de estos métodos sería algo así:</p>

<pre><code>- (NSString *) name{
    return self-&gt;name;
}

- (void) setName: (NSString * )newName{
    self-&gt;name = newName;
}
</code></pre>

<p>Existe una notación que nos permite invocar a los métodos usando el punto
<code>[mahou setName:@"Mahou"];</code> es exactamente igual que <code>mahou.name = @"Mahou";</code>, esta notación punto solo es válida si cumples la convención de nombrar el getter con el nombre de la variable y el setter como setNombre de la variable de instancia.</p>

<p>La variable self es un puntero al propio objeto, pero hay convenio para nombrar las variables privadas de instancias, con el prefijo <code>_</code> para evitar confusión:</p>

<pre><code>- (void) setCountry: (NSString * )newCountry{
    _country = newCountry;
}
</code></pre>

<p>Con <code>@property</code> definimos una variable de instancia y el compilador le añade setter y getter:</p>

<pre><code>@property (nonatomic, strong) NSString *country;
</code></pre>

<p>Debes especificar con <code>@synthesize country = _country;</code> si quieres programar tu propio setter y getter. Cuando se establece una propiedad booleana como <code>@property (nonatomic) BOOL married;</code> podemos renombrar el nombre del getter <code>@property (nonatomic, getter = isMarried) BOOL married;</code>.</p>

<h5>Métodos inicializadores</h5>

<p>Para ilustrar la inicialización de los objetos vamos a crear una nueva clase llamada <em>Person</em>.</p>

<p>En la intefaz creamos por ejemplo estas propiedades:</p>

<pre><code>@property (nonatomic, strong) NSString *name;
@property (nonatomic) NSUInteger age;
@property (nonatomic, strong) NSString *address;
@property (nonatomic, getter = isMarried) BOOL married;
</code></pre>

<p>Podemos declarar tantos métodos inicializadores que queramos pero todos deben empezar por init. Normalmente se suelen anidar de manera que un método inicializador puede llamar a otro más descriptivo pasándole valores por defecto. Aquel que recibe más parámetros y por tanto describe mejor al objeto que iniciliza se denomina <em>designated initializer</em>. Un ejemplo:</p>

<pre><code>- (id) init;
- (id) initWithName: (NSString *)name;
- (id) initWithName: (NSString *)name andAddress: (NSString *)address;
- (id) initWithName: (NSString *)name andAddress: (NSString *)address age: (NSUInteger) age;
</code></pre>

<p>La implementación de estos inicializadores podría ser así:</p>

<pre><code>- (id) initWithName: (NSString *)name andAddress: (NSString *)address age: (NSUInteger) age{
    self = [super init];
    if(self){
        _name = name;
        _address = address;
        _age = age;
    }
    return self;
}
</code></pre>

<table>
<thead>
<tr>
<th> Nota </th>
</tr>
</thead>
<tbody>
<tr>
<td> <em>En los métodos inicializadores no se usan las propiedades, son los único métodos que deben usar las variables de instancia</em> </td>
</tr>
</tbody>
</table>


<p>Los siguientes métodos podrían implementarse así:</p>

<pre><code>- (id) initWithName: (NSString *)name andAddress: (NSString *)address{
    self = [self initWithName:name andAddress:address age:99];
    return self;
}

- (id) initWithName: (NSString *)name{
    self = [self initWithName:name andAddress:@"Sin definir"];
    return self;
}

- (id) init{
    self = [self initWithName:@"Anonimo"];
    return self;
}
</code></pre>

<h5>Métodos de clase</h5>

<p>A veces es interesante crear un método que solo sirva para inicializar un objeto con los parámetros ya predefinidos. Para eso se usan los métodos de clase, que se caracterizan porque sirven para inizializar objetos, no pueden acceder a las variables de instancia y en la interfaz/implementacións viene precedidos por un signo más. Ésta podría ser un método de clase de Person:</p>

<pre><code>+ (id) personWithName: (NSString *)name{
    return [[Person alloc] initWithName:name];
}
</code></pre>

<p>Y así se podría crear una persona <code>Person *homer = [Person personWithName:@"Homer Simpson"];</code></p>

<h3>Primeros test de unidad</h3>

<p>En los proyectos de Xcode, por defecto se crea un directorio donde crear la clases de testeo. Por lo general son clases que extienden a <em>XCTestCase</em>, y en la implementación estarán los métodos que prueban el comportamiento de las clases. Éste sería un ejemplo de test:</p>

<pre><code>#define TEST_ERROR_MSG @"OMG! 💀"
...
- (void)testCanCreateABeerList {
    BeerList *allBeers = [[BeerList alloc] init];
    XCTAssertNotNil(allBeers, TEST_ERROR_MSG);
    XCTAssertEqual(0, [allBeers count], @"Expected %d but found %lu!", 0, [allBeers count]);
}
</code></pre>

<h6>Nota</h6>

<p>Desarrollo guiado por pruebas <code>TDD</code> es una técnica de programación que consiste en implementar primero los test unitarios e ir añadiendo el código necesario mínimo hasta pasar la prueba con éxito.</p>

<h6>Nota</h6>

<p>Así se puede iterar un array usando bloques:</p>

<pre><code>[[allBeers allBeers] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Beer *beerToTest = (Beer *)obj;
    NSLog(@"%lu",(unsigned long)idx);
}];
</code></pre>

<h3>KVC: Key Value Coding</h3>

<p>KVC es un mecanismo que nos da la posibilidad de obtener y definir propiedades de una clase especificando identificadores (key) que representan los nombres de los atributos a los que queremos acceder.</p>

<p><code>[allBeers valueForKey:@"count"]</code> es igual que <code>allBeers.count</code></p>

<h3>Leer archivo plist</h3>

<p>Despues de crear y rellenar un archivo plis con esta estructura:</p>

<p>Desde la lista de cevezas podemos leerlo, y añadirlo como cerveza:</p>

<pre><code>NSString *fileNameAndPath = [[NSBundle mainBundle]pathForResource:fileName ofType:@"plist"];
NSArray *array = [NSArray arrayWithContentsOfFile:fileNameAndPath];

for (NSDictionary *dict in array) {
   Beer *beer = [[Beer alloc] init];
   beer.name = [dict objectForKey:@"name"];
   beer.grade = [[dict objectForKey:@"grade"] integerValue];
   beer.color = [dict objectForKey:@"color"];
   beer.country = [dict objectForKey:@"country"];

   []self addBeer:beer];
}
</code></pre>

<h3>MRC (Manual Reference Counting) y ARC (Automatic Reference Counting)</h3>

<p>Hasta el iOS 5, el desarrollador tenía que mantener manualmente el seguimiento de la cantidad de referencias correspondientes a cada uno de los objetos creado (MRC), liberándolo correctamente después de que el objeto ya no fuese necesario para nadie más. De modo que, por ejemplo, antes de iOS 5, era preciso escribir algo como esto:</p>

<pre><code>NSArray *anArray = [[NSArray alloc] initWithObjects:@"one", @"two", nil];
self.myArrayProperty = anArray;
[anArray release];
</code></pre>

<p>A partir de iOS 5, el compilador añade automáticamente el código necesario para gestionar la memoria. Pero es preciso conocer el mecanismo por si nos tenemos que enfrentar con código pre-iOS 5.</p>

<p>¿Cuándo tengo que liberar memoria? Cuando añado un <code>alloc</code>, <code>new</code> o <code>copy</code> hay liberar con <code>release</code>.</p>

<p>¿Cuándo tengo que hacer <code>-retainCount</code>? <a href="http://whentouseretaincount.com/">Aquí la respuesta</a>.</p>

<hr />

<p><em><strong>Nota rápida:</strong> Solo se debe usar <code>weak</code> en los delegados y outlet.</em></p>

<hr />

<h3>Ejercicio final de semana:</h3>

<p>Para acabar la semana, afianzamos los conceptos con un ejercicio: <a href="http://cl.ly/VvPD">Enunciado</a>.</p>

<p>Está resuelto en este repositorio: <a href="https://github.com/rafaparadela/Ironhack-week-1-iOS-exercises---Bars-app">Resolución</a></p>

<h3>Algunas anotaciones extras</h3>

<p><strong><a href="http://alcatraz.io/">Alcatraz</a></strong> The package manager for Xcode:</p>

<p><strong><a href="https://github.com/venmo/synx">Synx</a></strong> A command-line tool that reorganizes your Xcode project folder to match your Xcode groups</p>

<p><strong><a href="http://simpholders.com/">SimPholders</a></strong> A small utility for fast access to your iPhone Simulator apps.</p>

<p><strong><a href="https://popapp.in/">POP</a></strong> Prototyping on Paper | iPhone App Prototyping Made Easy.</p>

<p><strong><a href="http://cocoapods.org/">CocoaPods</a></strong> The Dependency Manager for Objective C.</p>

<ul>
<li>Editas Podfile con las dependencias</li>
<li>pod install instala las dependencias</li>
<li>Y desde ese momento, se debe abrir el workspace y no el xcodeproject.</li>
</ul>


<h4>Categorias:</h4>

<ul>
<li>Se crea una categoria sobre "algo".</li>
<li>Si escribes un método que ya existe, la sobreescribe.</li>
<li>Lo importamos en el pch de sipporting files para tenerlo en todos.</li>
<li>Las categorias en principio no soportaban propiedades, es mas facil definir una variable de instancia.</li>
</ul>


				  <!-- %%%%%% -->
				  
			  </div>

			  <div class="bs-docs-section" id="w02-section">
				  <h1 id="w02" class="page-header">Semana 2</h1>

				  <!-- &&&&&& -->
				  


<p>Empezamos planificando la semana y presentándonos a un nuevo profesor: <a href="https://twitter.com/frsevillano">Fran Sevillano</a>.</p>

<h3>MVC</h3>

<p>El patrón Model-View-Controller consiste en dividir el código en 3 capas diferenciadas, donde los modelos representan los datos que se van a manejar, las vistas representan los elementos que conforman la interfaz de usuario y los controladores, que responden a los eventos para interactuar con las vistas y con los modelos. Las vistas en Objective-c no tiene acceso a los modelos directamente sino que se comunica con los controladores que les proveerá de la información necesaria. Esta cominicación "fluye" por varias vías.</p>

<p><img src="http://res.cloudinary.com/rafaparadela/image/upload/v1402386815/Captura_de_pantalla_2014-06-09_a_la_s_19_23_21_rqrgvx.png" alt="image" /></p>

<h5>Target-Action</h5>

<p>Esta técnica consiste en enviar un mensaje cuando un evento ocurre. El objeto <code>target</code> recibirá un mensaje, <code>action</code> cuando ocurra el evento <code>controlEvents</code></p>

<pre><code>(void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents
</code></pre>

<p>Hay muchos objetos en el SDK al los que se les puede enviar mensajes en respuesta a un evento. Como por ejemplo: UIButton, UILabel, UISwitch, UISlider, UISegmentedControl, UIPageControl, UIStepper, etc.</p>

<p>Así podemos añadir un botón a la vista, y asignarle un título.</p>

<pre><code>UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];
button.frame = CGRectMake(10, 10, 100, 50);
[self.view addSubview:button];
[button setTitle:@"Normal" forState:UIControlStateNormal];
[button setTitle:@"Resaltado" forState:UIControlStateHighlighted];
</code></pre>

<p>Si queremos mandarle un mensaje cuando sea pulsado, y desencadene la ejecución del método <code>buttonPressed</code>:</p>

<pre><code>[button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchDown];
</code></pre>

<p>El manejo de los labels es similar. Así añadimos un label, con el texto <em>Hola</em>, con la tipogradía <em>Georgia</em> de tamaño 20 puntos en color verde:</p>

<pre><code>UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(300, 10, 300, 50)];
[self.view addSubview:label];
[label setText:@"Hola"];
[label setFont:[UIFont fontWithName:@"Georgia" size:20]];
[label setTextColor:[UIColor greenColor]];
</code></pre>

<p>Un ejercicio sencillo, dadas las propiedades <code>UILabel * mylabel</code> y <code>UISwitch * myswitch</code> ¿Cómo cambiar la manera en la que el sistema truca el texto del label, dependiendo de si un switch está activado o desactivado?</p>

<pre><code>@property (nonatomic, strong) UILabel * mylabel;
@property (nonatomic, strong) UISwitch * myswitch;

...

- (void)exercise
{

    self.myswitch = [[UISwitch alloc] initWithFrame:CGRectMake(10, 140, 300, 50)];
    [self.view addSubview:self.myswitch];
    [self.myswitch addTarget:self action:@selector(setLineBreakMode) forControlEvents:UIControlEventValueChanged];

    self.mylabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 190, 120, 50)];
    [self.view addSubview:self.mylabel];
    [self.mylabel setText:@"Lorem ipsum dolor sit amet"];
    [self.mylabel setBackgroundColor:[UIColor greenColor]];

}

- (void)setLineBreakMode
{
    if ([self.myswitch isOn]) {
        [self.mylabel setLineBreakMode:NSLineBreakByTruncatingHead];
    }else{
        [self.mylabel setLineBreakMode:NSLineBreakByTruncatingTail];
    }

}
</code></pre>

<p>Y un sencillo ejemplo de cómo crear un UISegmentedControl, con las opciones <em>Hola</em> y <em>Adiós</em> y que mande el mensaje <code>setLineBreakMode</code> cuando cambie su valor:</p>

<pre><code>UISegmentedControl * mysegmented = [[UISegmentedControl alloc] initWithItems:@[@"Hola",@"Adios"]];
[mysegmented setFrame:CGRectMake(10, 390, 200, 50)];
[self.view addSubview:mysegmented];
[mysegmented addTarget:self action:@selector(setLineBreakMode) forControlEvents:UIControlEventValueChanged];
</code></pre>

<h3>Delegation</h3>

<p>Consiste en delegar parte de la funcionalidad de un objeto a otro, habilitando por ejemplo la posibilidad de personalizar multiples vistas desde un solo controlador.</p>

<p>Para establecer la relación de delegación se debe llevar a cabo los siguientes pasos:</p>

<ul>
<li>La clase delegada debe definir un protocolo (con el mismo nombre del controlador y el sufijo <em>Delegate</em>), que consiste en declarar una serie de métodos.</li>
</ul>


<pre><code>@protocol MyViewControllerDelegate &lt;NSObject&gt;
- (void) oneMethod;
@end
</code></pre>

<ul>
<li>La clase delegada debe tener una propiedad (<em>weak</em>) llamada <code>delegate</code>, del tipo genérico <code>id</code> con la restricción de que extienda el protocolo:</li>
</ul>


<pre><code>@property (nonatomic, weak) id&lt;MyViewControllerDelegate&gt; delegate;
</code></pre>

<ul>
<li>Que el método delegador extienda el protocolo:</li>
</ul>


<pre><code>@interface OtherViewController ()&lt;MyViewControllerDelegate&gt;
</code></pre>

<ul>
<li>Que el método delegador implemente los métodos del protocolo:</li>
</ul>


<pre><code>- (void) oneMethod{
    NSLog(@"Pollito");
}
</code></pre>

<ul>
<li>Para establecer que un objeto de <code>OtherViewController</code> sea el delegador de un objeto <code>MyViewController</code>, sería algo así (si se hace desde <code>OtherViewController</code>):</li>
</ul>


<pre><code>self.anyViewController = [[MyViewController alloc] init];
self.anyViewController.delegate = self;
</code></pre>

<ul>
<li>Ahora desde <code>MyViewController</code> podemos delegar algunas funcionalidades sobre <code>OtherViewController</code>, en este caso delegar el método <code>oneMethod</code>:</li>
</ul>


<pre><code>[self.delegate oneMethod];
</code></pre>

<p>Normalmente se usa la técnica <em>delegate</em> para definir la funcionalidad de un conjunto de controles como: UITextField y su protocolo UITextFieldDelegate con el que podemos personalizar su comportamiento, UITextView y UITextViewDelegate, UIAlertView, UIActionSheet, etc.</p>

<h3>Notificaciones</h3>

<p>Las notificaciones se usan para comunicar los modelos con los controladores. Consiste en enviar un mensaje de difusión, con cierta información, que es escuchada por aquellos objetos que se subscriban. Es la clase <code>NSNotificationCenter</code> la encargada de este flujo.</p>

<p>El envío y lectura de notificaciones se entiende mucho mejor con un ejemplo. Imaginemos dos vistas diferentes independeientes, gestionadas mediante dos ViewControllers. En la primera de las vistas tenemos un UITextField y la segunda un UILabel. El propósito es que cuando se cambie campo de texto de la primera vista, se escriba en el label de la segunda vista exactamente el mismo texto:</p>

<pre><code>@property (nonatomic, strong) UITextField *textField;

...

- (void)exercise
{
    self.textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 40, 300, 40)];
    [self.view addSubview:self.textField];    
    [self.textField addTarget:self action:@selector(changedField) forControlEvents:UIControlEventEditingChanged];


} 

- (void)changedField{
    [[NSNotificationCenter defaultCenter] postNotificationName:@"myTextNotification" object:self userInfo:@{@"mytexto" : self.textField.text}];
}
</code></pre>

<p>Así estaríamos enviando una notificación llamada <em>myTextNotification</em> con los datos serializados en un diccionario llamado <em>userInfo</em>, en este caso el nuevo texto como valor cuya clave es <em>@"mytexto"</em>. Los recibiría todo aquel que se suscriba a dicha notificación. En este caso desde la segunda vista:</p>

<pre><code>@property (nonatomic, strong) UILabel * mylabel;

...

- (void)exercise
{
    self.mylabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 90, 300, 40)];
    [self.view addSubview:self.mylabel];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveNotification:) name:@"myTextNotification" object:nil];

}

- (void)receiveNotification:(NSNotification *)notification
{
    NSDictionary *userInfo = notification.userInfo;
    self.mylabel.text = [userInfo objectForKey:@"texto"];
}
</code></pre>

<p>De esta manera recibiría la notificación <em>myTextNotification</em> y se la enviaría al método <em>receivenotification</em> que actualiza el texto del label.</p>

<h2>Martes 10</h2>

<h3>View Controllers</h3>

<p>Los controladores de las vistas son el nexo entre los datos y lo que se presenta al usuario. Aunque la SDK provee de una serie de controladores de vistas por defecto con una serie de comportamientos establecidos, nosotros podemos crearnos las nuestras propias.</p>

<p>Las vistas representan un area que muestra un contenido y recibe los eventos táctiles. Pueden estar anidadas y animadas y desconocen qué hay en su entorno. Cada vista solo puede ser gestionada por un solo controlador.</p>

<h5>Controladores de contenido</h5>

<p>Presentan contenido a través de una vista o una jerarquía de las mismas. Estos controladores normalmente conocen el subconjunto de datos de la aplicación relevantes a su papel en la aplicación. Si tenemos un controlador de la vista para mostrar el perfil de un usuario, el controlador de la vista conocerá cuáles son los datos del usuario como su foto, nombre, etc.</p>

<p>Cada controlador de la vista es responsable de gestionar todas las vistas en la jerarquía de una sola vista. Esto es que hay una correspondencia 1–1 entre el controlador y la vista. No se deberían utilizar múltiples controladores para gestionar una sola vista ni un solo controlador para gestionar varias jerarquías de vistas. De nuevo, la regla (en general) es utilizar un controlador por cada pantalla de la aplicación.</p>

<h5>Controladores Contenedores</h5>

<p>Tienen contenido que pertenece a otros controladores de vista. Éstos otros controladores de vista han sido explícitamente asignados como hijos de este controlador de vista. Un controlador de vista puede ser a su vez padre e hijo de otros controladores de vista, lo que establece a su vez una jerarquía de controladores de vista.</p>

<p>Un controlador contenedor gestiona una jerarquía de vistas como un controlador normal. Además también puede añadir las vistas de sus controladores hijo como parte de la jerarquía de sus vistas. El controlador padre decide donde quiere poner la vista de su controlador y hijo y que tamaño tiene que tener. Por lo demás el controlador hijo es el responsable de gestionar su propia jerarquía de vistas.</p>

<h5>Inicialización de un controlador de la vista</h5>

<p>Cuando alguna parte de la aplicación pide la vista al controlador y ésta no está en memoria. El controlador la carga en memoria y la almacena en su propiedad view. Los pasos que ocurren en el proceso de carga son:</p>

<ul>
<li>El controlador llama al método loadView que carga la vista.</li>
<li>El controlador llama a su método viewDidLoad que permite a la subclase hacer cualquier tipo de carga adicional.</li>
</ul>


<p>Ambos loadView y viewDidLoad pueden ser sobrescritos para facilitar el comportamiento deseado por el controlador.</p>

<p><img src="http://res.cloudinary.com/rafaparadela/image/upload/v1402871618/Captura_de_pantalla_2014-06-15_a_la_s_16_28_27_amxpjg.png" alt="image" /></p>

<h5>Creando vistas de forma programática</h5>

<p>Para ellos, tendremos que sobreescribir el método loadView y en él.
- Crear una vista raíz para el controlador.</p>

<ul>
<li>Crear vistas adicionales y añadirlas a la vista raíz.</li>
<li>Asignar la vista raíz a la propiedad view del controlador.</li>
</ul>


<p>Es importante no llamar a super loadView ya que esto lanza el
comportamiento habitual y es un malgasto de recursos.</p>

<h5>Soportando múltiples orientaciones de interfaz</h5>

<p>Gracias al acelerómetro, las aplicaciones pueden conocer la orientación actual del dispositivo. Por defecto, una aplicación soporta orientación vertical y horizontal. Cuando ésta cambia, el dispositivo manda una notificación <code>UIDeviceOrientationDidChangeNotification</code>. Por defecto, UIKit recoge esta notificación y realiza los cambios pertinentes. Esto quiere decir que, excepto unas pocas excepciones, no necesitaríamos hacer nada más.</p>

<p>Cuando cambia la orientación, la ventana es redimensionada para encajar en la nueva orientación. La ventana también ajusta el el frame de su controlador raíz para coincidir con el nuevo tamaño. Por tanto, la forma más fácil de soportar múltiples orientaciones en nuestro controlador es configurar su jerarquía de vistas para que sus subvistas se actualicen cada vez que el frame de la vista raíz cambie.</p>

<p>Si no queremos el comportamiento por defecto, podemos controlar:</p>

<ul>
<li>Las orientaciones que queremos que soporte la app.</li>
<li>Como una rotación entre dos orientaciones es animada en pantalla.</li>
</ul>


<p>Ejemplos:</p>

<p>Sobreescribiendo <code>supportedInterfaceOrientations</code> podemos indicar las orientaciones soportadas:</p>

<pre><code>-  (NSUInteger)supportedInterfaceOrientations{
    return (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskPortraitUpsideDown);
}
</code></pre>

<p>Evitando que se auto-rote:</p>

<pre><code>- (BOOL)shouldAutorotate
{
    return NO;
}
</code></pre>

<p>A veces tendremos un controlador cuyo contenido se vea mejor en cierta orientación. Aunque soporte otras orientaciones, queremos que al presentarse salga en esa. Para ello, deberemos sobreescribir el método <code>preferredInterfaceOrientationForPresentation</code>. Esta orientación debe estar incluida en las <code>supportedInterfaceOrientations</code>:</p>

<pre><code>- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{
    return UIInterfaceOrientationPortraitUpsideDown;
}
</code></pre>

<h5>Presentando Controladores desde otros controladores</h5>

<p>Cualquier tipo de controlador puede ser presentado por la aplicación. Sin embargo, solo deberíamos presentar nuevos controladores cuando queramos transmitir un significado específico sobre la relación de la jerarquía previa y la nueva presentada.</p>

<p>Cuando presentas un controlador modal, el sistema crea una relación entre el controlador que hizo la presentación y el presentado. El controlador presentador actualiza su propiedad presentedViewController con el controlador presentado y el presentado actualiza su propiedad presentingViewController con el presentador. Pasos a seguir.</p>

<ol>
<li>Crear el controlador a presentar.</li>
<li>Establecer la propiedad modalTransitionStyle del controlador con el valor deseado.</li>
<li>Asignar un delegate al view controller. Típicamente será el controlador presentador. El delegado será usado por el controlador presentado para informar al presentador cuando está listo para ser ocultado. También podría comunicar otra información.</li>
<li>Llamar al método presentViewController:animated:completion pasando como argumento el controlador a presentar.</li>
</ol>


<p>Un ejemplo, de un ViewController con un UIButton que al pulsar muestra otra vista con el efecto "Cover", además es delegado de ella y por tanto implementa el método para ocultar al segunda vista:</p>

<pre><code>@interface IHViewController ()&lt;IHPresentedViewControllerDelegate&gt;
@property (nonatomic, strong) UIButton *btn1;
@property (nonatomic, strong) IHPresentedViewController * myViewController;
@end

...

- (void)exercise1
{
    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 10, 200, 30);
    [self.btn1 setTitle:@"Boton1" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(transitionCover) forControlEvents:UIControlEventTouchUpInside];

}

...

- (void) transitionCover{
    self.myViewController = [[IHPresentedViewController alloc] init];
    self.myViewController.delegate = self;
    self.myViewController.modalTransitionStyle = UIModalTransitionStyleCoverVertical;
    [self presentViewController:self.myViewController animated:YES completion:nil];

    NSLog(@"cover");
}

...

- (void) dismissMe{
    [self.myViewController dismissViewControllerAnimated:YES completion:nil];
}
</code></pre>

<p>En el controlador delegado:</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];

    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 10, 200, 30);
    [self.btn1 setTitle:@"Volver" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(volverAtras) forControlEvents:UIControlEventTouchUpInside];

}

...

- (void) volverAtras{
    [self.delegate dismissMe];
}
</code></pre>

<h5>Controladores contenedores</h5>

<p>Son una parte vital del diseño de apps en iOS. Nos permiten descomponer la app en piezas más pequeñas y simples, cada una manejada por un controlador dedicado a esa tarea. Los contenedores permiten a esos controladores trabajar juntos para construir una interfaz impoluta.</p>

<p>iOS nos provee de contenedores standard como son UINavigationController o UITabBarController, sin embargo a veces necesitamos un flujo personalizado que no podemos encontrar en los controladores del sistema. Si necesitamos una organización especial de controladores hijos con una navegación especial o transiciones animadas de un tipo en particular, tendremos que crearnos uno personalizado.</p>

<p>Ejemplo: En un ViewController, añadir dos UIButton, uno para añadir una subvista con el fondo rojo y otro para eliminarla.</p>

<pre><code>@property (nonatomic, strong) UIButton *btn1;
@property (nonatomic, strong) UIButton *btn2;
@property (nonatomic, strong) UIViewController *myViewController;

...

- (void)exercise1
{

    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 20, 200, 30);
    [self.btn1 setTitle:@"Boton1" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(openChild) forControlEvents:UIControlEventTouchUpInside];

    self.btn2 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn2.frame = CGRectMake(200, 20, 200, 30);
    [self.btn2 setTitle:@"Boton2" forState:UIControlStateNormal];
    [self.view addSubview:self.btn2];
    [self.btn2 addTarget:self action:@selector(closeChild) forControlEvents:UIControlEventTouchUpInside];

    self.myViewController = [[UIViewController alloc] init];
    self.myViewController.view.frame = CGRectMake(20, 100, 100, 100);
    [self.myViewController.view setBackgroundColor: [UIColor redColor]];
}

- (void) openChild{

    [self addChildViewController:self.myViewController];
    [self.view  addSubview:self.myViewController.view];
    [self.myViewController didMoveToParentViewController:self];
    NSLog(@"Entra");
}

- (void) closeChild{
    [self.myViewController willMoveToParentViewController:nil];
    [self.myViewController.view removeFromSuperview];
    [self.myViewController removeFromParentViewController];
    NSLog(@"Sale");
}
</code></pre>

<h4>Arquitectura de Vistas</h4>

<p>Un objeto UIView define una región rectangular de la pantalla que maneja los dibujos y loe eventos táctiles en esa región. Una vista puede también actuar como padre para otras vistas y coordinar el lugar y el tamaño de esas subvistas.</p>

<p>Cada vista tiene su correspondiente objeto "<em>layer</em>" que puede ser accedido con la propiedad <code>layer</code> de esa vista.</p>

<h5>Las propiedades <em>Frame</em>, <em>Bounds</em> y <em>Center</em></h5>

<p>La propiedad <strong>Frame:</strong> contiene el rectángulo (tamaño y posición) que ocupa en el sistema de cordenadas de la vista padre.</p>

<p>La propiedad <strong>Bounds:</strong> contiene el rectángulo (tamaño y posición) que ocupa el contenido en el sistema de cordenadas de la propia vista.</p>

<p>La propiedad <strong>Center:</strong> representa el punto del central de la vista en el sistema de coordenadas del padre.</p>

<p>¿Como se crea una vista?</p>

<pre><code>￼CGRect  viewRect = CGRectMake(0, 0, 100, 100);
UIView* myView = [[UIView alloc] initWithFrame:viewRect];
</code></pre>

<p>Ejemplo: Crear 3 subvistas, posicionarlas haciendo que se solapen y modificar el zIndex de alguna de ellas:</p>

<pre><code>@property (nonatomic,strong) UIView *myFirstView;
@property (nonatomic,strong) UIView *mySecondView;
@property (nonatomic,strong) UIView *myThirdView;
...
self.myFirstView = [[UIView alloc] initWithFrame:CGRectMake(30, 30, 300, 240)];
[self.myFirstView setBackgroundColor:[UIColor redColor]];
[self.view addSubview:self.myFirstView];

self.mySecondView = [[UIView alloc] initWithFrame:CGRectMake(90, 90, 300, 240)];
[self.mySecondView setBackgroundColor:[UIColor blueColor]];
[self.view addSubview:self.mySecondView];
[self.view sendSubviewToBack: self.mySecondView];

self.myThirdView = [[UIView alloc] initWithFrame:CGRectMake(60, 60, 300, 240)];
[self.myThirdView setBackgroundColor:[UIColor yellowColor]];
[self.view addSubview:self.myThirdView];
[self.view insertSubview:self.myThirdView atIndex:1];
</code></pre>

<p>Otro ejemplo. Añadir una subvista que contenga una imagen que respete sus proporciones y rellene todo el rectángulo de la vista:</p>

<pre><code>@property (nonatomic, strong) UIImageView * myFirstImageView;
...
myFirstImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"guinness"]];
[myFirstImageView setFrame:CGRectMake(400, 400, 300, 240)];
[myFirstImageView setBackgroundColor:[UIColor lightGrayColor]];
[myFirstImageView setContentMode:UIViewContentModeScaleAspectFill];
[myFirstImageView setClipsToBounds:YES];
[self.view myFirstImageView];
</code></pre>

<p>Otro ejemplo: Modifica mediante una animación la opacidad, le ubicación y las dimensiones de la subvista anterior:</p>

<pre><code>[UIView animateWithDuration:2.0 animations:^{
    self.myFirstImageView.alpha = 0.5;

    CGRect frame = self.myFirstImageView.frame;
    frame.origin.x=80;
    self.myFirstImageView.frame=frame;

    CGRect bounds = self.myFirstImageView.bounds;
    bounds.size.width=140;
    self.myFirstImageView.bounds=bounds;
}];
</code></pre>

<p>Otro ejemplo: Hacer que una subvista sea transparente mediante una animación, y cuando esta acabe se vuelva a mostrar:</p>

<pre><code>[UIView animateWithDuration:1.0 animations:^{
    self.myView.alpha = 0;
} completion:^(BOOL finished) {
    self.myView.alpha = 1.0;
}];
</code></pre>

<p>Otro ejemplo: Rotar una subvista (UIImageView), controlando el ángulo con un UISlider:</p>

<pre><code>@property (nonatomic, strong) UIImageView * myImageView;
@property (nonatomic, strong) UISlider * rotateSlider;

...

self.rotateSlider = [[UISlider alloc] initWithFrame:CGRectMake(400, 700, 300, 40)];
[self.rotateSlider setMaximumValue:M_PI];
[self.rotateSlider setMinimumValue:0];
[self.view addSubview:self.rotateSlider];
[self.rotateSlider addTarget:self action:@selector(rotateImage:) forControlEvents:UIControlEventValueChanged];

...

- (void)rotateImage: (UISlider *) slider{
    CGAffineTransform oneTransform = CGAffineTransformMakeRotation(slider.value);
    self.myImageView.transform = CGAffineTransformConcat(oneTransform);
}
</code></pre>

<hr />

<h4>Nuevo profesor</h4>

<p>El jueves nos presentamos ante <a href="https://twitter.com/foolonhill">Ricardo Sanchez</a> y empezamos viendo los <code>UITableView</code>.</p>

<h5>UITableView</h5>

<p>Estas vistas son, con diferencia, el componente iOS más popular llegando hasta el 94% de las apps, ya que pueden mostrar muchos recursos  usando muy poca memoria.</p>

<p>Las TableView se componen de:</p>

<ul>
<li><code>UITableCell</code>'s</li>
<li>Header y Footer de cada sección.</li>
<li>Header y Footer de la propia TableView</li>
<li>Datasource</li>
<li>Delegate</li>
</ul>


<h5>UITableViewCell</h5>

<p>Las celdas de una TableView pueden ser estáticas o dinámicas, hay diferentes estilos por defectos, pero son muy fácilmente customizables. Para su uso es necesario definir su "Reuse Identifier" y su posición en la tabla/sección viene definida por <code>NSIndexPath</code>.</p>

<h5>UITableViewController</h5>

<p>Son un tipo particular de UIViewController que incluyen el Delegate y Datasource de la tabla y además aportan más funcionalidades.</p>

<p>El Datasource exige la implementación de estos dos métodos:</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>

<p>Es necesario también definir la vista UITableViewCell que se reusará, a través de su identificador:</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath
￼
</code></pre>

<hr />

<p>Ejemplo de tabla con secciones:</p>

<p>Para este ejemplo vamos a usar un modelo, que contiene una lista de casas (Juego de Tronos) y cada casa tiene un listado de personas.</p>

<pre><code>self.model = [[GotModel alloc] init];
[self.model cargaModelo];

...


- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
    return self.model.casas.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    Casa *casa = [self.model.casas objectAtIndex:section];
    return casa.personajes.count;
}

- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{
    Casa *casa = [self.model.casas objectAtIndex:section];
    return casa.nombre;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"celdaPersonaje" forIndexPath:indexPath];
    Casa *casa = [self.model.casas objectAtIndex:indexPath.section];
    Personaje * personaje = [casa.personajes objectAtIndex:indexPath.row];
    cell.textLabel.text = personaje.nombre;
    cell.detailTextLabel.text = personaje.descripcion;
    return cell;
}
</code></pre>

<h3>Customize cells</h3>

<p>Para crear tu propia celda:
- Crea tu clase que extienda de UITableViewCell
- En el storyboard, indicas que la celda sea de la clase que hemos creado.
- Ponemos que sea tipo custom y le ponemos un identificador.
- Le metemos los elementos que queramos y creamos los outlet (En el .h de nuestra clase).
- Por ultimo en nuestra UITableViewController:</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"celdaPersonaje" forIndexPath:indexPath];
    Casa *casa = [self.model.casas objectAtIndex:indexPath.section];
    Personaje * personaje = [casa.personajes objectAtIndex:indexPath.row];
    cell.myLabel.text = personaje.nombre;
    cell.myImage.image = [UIImage imageNamed:personaje.imagen];
    return cell;

}
</code></pre>

<p>Para cambiar el alto de la celda:</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 70.0;
}
</code></pre>

<h5>UITableViewDelegate</h5>

<p>Para que cuando pinche en una celda que te lleve a otra vista con info.
Y el nuevo controlador</p>

<pre><code>@property (weak, nonatomic) IBOutlet UIImageView *myImagen;
@property (weak, nonatomic) IBOutlet UITextView *myTextArea;
@property (weak, nonatomic) Personaje* myPersonaje;

...

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.

    self.myImagen.image = [UIImage imageNamed:self.myPersonaje.imagen];
    self.myTextArea.text = self.myPersonaje.descripcion;
    self.title = self.myPersonaje.nombre;
}
</code></pre>

<p>Creamo segue con un identificador <code>mySegue</code>:</p>

<pre><code>
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [self performSegueWithIdentifier:@"mySegue" sender:self];
}

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{
    if([segue.identifier  isEqual: @"mySegue"]){
        MySecondViewController* mySecondView = segue.destinationViewController;

        NSInteger casaId = self.tableView.indexPathForSelectedRow.section;
        Casa * casa = [self.model.casas objectAtIndex:casaId];

        NSInteger personajeId = self.tableView.indexPathForSelectedRow.row;
        Personaje* personaje = [casa.personajes objectAtIndex:personajeId];

        mySecondView.myPersonaje = personaje;

        NSLog(@"%d", personajeId);

    }

}
</code></pre>

<p>Cambiar el header de una section:</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 100.0;
}

- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{
    Casa * casa = [self.model.casas objectAtIndex:section];
    UIImage *logo = [UIImage imageNamed:casa.imagen];
    UIImageView* myImageSectionView = [[UIImageView alloc] initWithImage:logo];
    return myImageSectionView;
}
</code></pre>

<h5>Borrar celdas</h5>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
{
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        NSInteger casaId = indexPath.section;
        Casa * casa = [self.model.casas objectAtIndex:casaId];
        NSInteger personajeId = indexPath.row;
        NSMutableArray* myarray = [[NSMutableArray alloc] initWithArray:casa.personajes];

        [myarray removeObjectAtIndex:personajeId];

        casa.personajes = myarray;

        [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];


    }
}
</code></pre>

<p>Si llamamos "deleteRowsAtIndexPaths" antes que se cambie el modelo, falla, la solución es ponerlo despues en encapsular ese bloque de codigo entre:</p>

<pre><code>[self.tableView beginUpdates];
...
[self.tableView endUpdates];
</code></pre>

<h5>Mover Celdas</h5>

<p>Para mover las celdas es neceario implementar estos dos métodos:</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath{
    return YES;
}

- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{

    // Aquí se implementa los cambios en el modelo.

}
</code></pre>

<!--#####Añadir celdas
Perdido

#####Search
Lio!!!
-->


<h5>UICollectionView</h5>

<p>Son un tipo especial de UITableView que incluyen <em>Layouts</em>, inicialmente de tipo <em>grid</em>. Apple aporta un tipo de layout muy fácil de manejar, llamado UICollectionViewFlowLayout. Los layouts pueden ser cambiados dinámicamente.</p>

<p>Las CollectionViews se componen de:</p>

<ul>
<li>UICollectionViewCell</li>
<li>SupplementaryViews</li>
<li>DecoratorViews</li>
</ul>


<p>Veamos el uso de estos componentes con un ejemplo:</p>

<h5>Cells</h5>

<p>Para definir las celdas de nuestro <code>UICollectionView</code> de ejemplo, vamos a crear una clase "<code>CustomCell</code>" que extienda de <code>UICollectionViewCell</code> con una propiedad pública del tipo <code>UIImageView</code>. En su método inicializador le añadimos características a la imagen:</p>

<pre><code>self.myImage = [[UIImageView alloc] initWithFrame:self.bounds];
[self.myImage setContentMode:UIViewContentModeScaleAspectFill];
[self.myImage setClipsToBounds:YES];
[self addSubview:self.myImage];

...

- (void)layoutSubviews{
    [super layoutSubviews];
    self.myImage.frame = self.bounds;
}
</code></pre>

<p>En el <code>UICollectionViewController</code>, lo hacemos delegado de <code>&lt;UICollectionViewDataSource&gt;</code>, e implmentamos estos métodos:</p>

<pre><code>@property (nonatomic, strong) UICollectionView *myCollectionView;
@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayout;

...

self.modelo = [[GotModel alloc] init];
[self.modelo cargaModelo];
self.myCollectionViewLayout = [[UICollectionViewFlowLayout alloc] init];
self.myCollectionViewLayout.itemSize = CGSizeMake(350, 80);
self.myCollectionViewLayout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
self.myCollectionViewLayout.minimumInteritemSpacing = 20;
self.myCollectionViewLayout.minimumLineSpacing = 20;
self.myCollectionViewLayout.scrollDirection = UICollectionViewScrollDirectionVertical;
self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 120);
self.myCollectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:self.myCollectionViewLayout];
self.myCollectionView.dataSource = self;
self.myCollectionView.delegate = self;
[self.myCollectionView setContentInset: UIEdgeInsetsMake(64, 0, 0, 0)];
[self.myCollectionView registerClass:[CustomCell class] forCellWithReuseIdentifier:@"cellIdent"];
[self.view addSubview:self.myCollectionView];

...

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{

    CustomCell *cell = [self.myCollectionView dequeueReusableCellWithReuseIdentifier:@"cellIdent" forIndexPath:indexPath];
    Casa* casa = [self.modelo.casas objectAtIndex:indexPath.section];
    Personaje* personaje = [casa.personajes objectAtIndex:indexPath.row];
    UIImage * myCellImage =  [UIImage imageNamed:[NSString stringWithFormat:@"%@.jpg", personaje.imagen]];
    cell.myImage.image = myCellImage;
    return cell;
}

- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView{
    return self.modelo.casas.count;
}

- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{
    Casa* casa = [self.modelo.casas objectAtIndex:section];
    return casa.personajes.count;
}
</code></pre>

<h5>Header</h5>

<p>Para definir el header,</p>

<pre><code>self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 30);

....

[self.myCollectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent"];

...

- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{

    UICollectionReusableView* myHeaderView = [self.myCollectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent" forIndexPath:indexPath];

    myHeaderView.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1];

    return myHeaderView;
}
</code></pre>

<h5>Lo vamos a hacer pero con una subclase</h5>

<ul>
<li>Creamos una clase de UICollectionReusableView (llamada por ejemplo CustomHeader)con un propiedad publica label:</li>
</ul>


<pre><code>@interface CustomHeader : UICollectionReusableView

@property (strong, nonatomic) UILabel * myLabel;

@end
</code></pre>

<p>Inicializamos el label;</p>

<pre><code>self.myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)];
self.myLabel.text = @"Hola";
[self.myLabel setTextAlignment:NSTextAlignmentCenter];
[self.myLabel setFont:[UIFont fontWithName:@"Helvetica" size:30.0]];
self.myLabel.textColor = [UIColor lightGrayColor];
[self addSubview:self.myLabel];
</code></pre>

<p> En el controlador principal:</p>

<pre><code>#import "CustomHeader.h"

...

- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{

    CustomHeader* myHeaderView = [self.myCollectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent" forIndexPath:indexPath];

    myHeaderView.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1];

    Casa* casa = [self.modelo.casas objectAtIndex:indexPath.section];

    myHeaderView.myLabel.text = casa.nombre;

    return myHeaderView;
}
</code></pre>

<h5>Añadir segment control para elegir vertical u horizontal</h5>

<ul>
<li>Creamos un segmen control, con storyboard y metemos IBoutlet y IBaction</li>
<li>Creamos dos layouts:</li>
</ul>


<pre><code>@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayout;
@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayoutHorizontal;
</code></pre>

<p>Implementamos los cambios:</p>

<pre><code>    self.myCollectionViewLayout = [[UICollectionViewFlowLayout alloc] init];
    self.myCollectionViewLayout.itemSize = CGSizeMake(100, 100);
    self.myCollectionViewLayout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
    self.myCollectionViewLayout.minimumInteritemSpacing = 20;
    self.myCollectionViewLayout.minimumLineSpacing = 20;
    self.myCollectionViewLayout.scrollDirection = UICollectionViewScrollDirectionVertical;
    self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 120);

    self.myCollectionViewLayoutHorizontal = [[UICollectionViewFlowLayout alloc] init];
    self.myCollectionViewLayoutHorizontal.itemSize = CGSizeMake(140, 140);
    self.myCollectionViewLayoutHorizontal.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
    self.myCollectionViewLayoutHorizontal.minimumInteritemSpacing = 20;
    self.myCollectionViewLayoutHorizontal.minimumLineSpacing = 20;
    self.myCollectionViewLayoutHorizontal.scrollDirection = UICollectionViewScrollDirectionHorizontal;
    self.myCollectionViewLayoutHorizontal.headerReferenceSize = CGSizeMake(120,self.myCollectionView.frame.size.height);
</code></pre>

<p>En el ibaction del segmentcontrol controlo el valor:</p>

<pre><code>- (IBAction)selectSegment:(id)sender {
    UISegmentedControl * segment = sender;

    if(segment.selectedSegmentIndex==0){
        [self.myCollectionView setCollectionViewLayout:self.myCollectionViewLayout animated:YES];
    }
    else{
        [self.myCollectionView setCollectionViewLayout:self.myCollectionViewLayoutHorizontal animated:YES];
    }

}
</code></pre>

<h5>CollectionView Delegate: Seleccionar varios elementos para elimiarlos</h5>

<p>Permitir el multiple selection:</p>

<pre><code>self.myCollectionView.allowsMultipleSelection = YES;
</code></pre>

<p>Para cambiar el estilo de la celda seleccionada, implemento el cambio en su clase</p>

<pre><code>- (void)setSelected:(BOOL)selected{
    [super setSelected:selected];

    if (selected) {
        [self.myImage setAlpha:0.5];
    }
    else{
        [self.myImage setAlpha:1.0];
    }
}
</code></pre>

<p>Creamos un IBAction del botón de borrar con este método:</p>

<pre><code>- (IBAction)delete:(UIBarButtonItem *)sender {
    [self.myCollectionView performBatchUpdates:^{

        [self.myCollectionView deleteItemsAtIndexPaths: self.selectedItems ];

        for (int c = 0; c &lt; self.modelo.casas.count; c++) {

            NSMutableIndexSet* indexSet = [[NSMutableIndexSet alloc] init];

            for(NSIndexPath * myIndexPath in self.selectedItems){
                if(myIndexPath.section == c){
                    NSLog(@"Entro");
                    [indexSet addIndex:myIndexPath.row];
                }

            }
            Casa* casa = [self.modelo.casas objectAtIndex:c];
            NSMutableArray* newList = casa.personajes.mutableCopy;
            [newList removeObjectsAtIndexes:indexSet];
            casa.personajes = newList.copy;
        }
        [self.selectedItems removeAllObjects];

    } completion:^(BOOL finished) {

    }];

}
</code></pre>

<hr />

<p>No estuve presente en el último ejercicio de la semana. Queda pendiente.</p>


				  
				  <!-- %%%%%% -->

			  </div>
			  
			  <div class="bs-docs-section" id="w03-section">
				  <h1 id="w03" class="page-header">Semana 3</h1>
				  
				  <!-- &&&&&& -->
				  
				  
<p>Empezamos la semana con la presentación del que será nuestro profesor los próximos trés días, <a href="http://victorbaro.com">Victor Baro</a>. Con él veremos tres temas importantes: Views, Drawing y Layers.</p>

<p>Para haces los ejercicios vamos a crear un proyecto que muestre los ejemplos que hacemos sobre estos tres temas, la única particularidad que hasta ahora no habíamos visto es la creación de varios storyboards y la instanciación de estos:</p>

<pre><code>- (IBAction)GoDrawing:(id)sender {
    UIStoryboard * drawingSB = [UIStoryboard storyboardWithName:@&quot;StoryboardDrawing&quot; bundle:[NSBundle mainBundle]];
    UINavigationController * nextVC = [drawingSB instantiateViewControllerWithIdentifier:@&quot;DrawingEntry&quot;];
    [self presentViewController:nextVC animated:YES completion:nil];
}
</code></pre>

<h3 id="vistas">Vistas</h3>

<p>Las vistas son objetos de la clase UIView (o de alguna subclase de esta), y representa un área rectangular en el que el usuario puede interaccionar. Una vista está dentro de su supervista, solo una <code>(UIView *) superview</code>. Y puede contener multiples subvistas <code>(NSArray *) subviews</code>.</p>

<p>Para manipular la jerarquía de subvistas tenemos:</p>

<ul>
<li>insertSubview:atIndex:</li>
<li>insertSubview:belowSubview:</li>
<li>insertSubview:aboveSubview:</li>
<li>exchangeSubviewAtIndex:withSubviewAtIndex:</li>
<li>bringSubviewToFront:</li>
<li>sendSubviewToBack:</li>
</ul>

<p>Cuando una vista se mueve o se borra, sus subvistas también. Así como si nivel de transparencia, que se hereda.
Con la propiedad de vista <em>clipsToBounds</em>, podemos establecer que las dimensiones de las subvistas sobresalgan o no de la vista.</p>

<h4 id="entendiendocgrectinset">Entendiendo CGRectInset</h4>

<p>Crear una subvista del mismo tamaño que la vista pero dejándole 10 puntos de &#8220;margen&#8221; <img src="http://f.cl.ly/items/1K2W1J3E0l030j3f2L21/Image%202014-06-16%20at%2011.56.01%20a.m..png" alt="image" /></p>

<pre><code>- (void) example01{
    CGRect blueViewFrame = CGRectMake(100, 100, 100, 200);
    UIView *blueView = [[UIView alloc] initWithFrame:blueViewFrame];
    blueView.backgroundColor = [UIColor blueColor];
    [self.view addSubview:blueView];

    CGRect greenViewFrame = CGRectInset(blueView.bounds, 10, 10);
    UIView *greenView = [[UIView alloc] initWithFrame:greenViewFrame];
    greenView.backgroundColor = [UIColor greenColor];
    [blueView addSubview:greenView];
    
}
</code></pre>

<h4 id="entendiendocgrectunion">Entendiendo CGRectUnion</h4>

<pre><code>// CGRectUnion
CGRect frame1 = CGRectMake(80.0, 100.0, 150.0, 240.0);
CGRect frame2 = CGRectMake(140.0, 240.0, 120.0, 120.0);
CGRect frame3 = CGRectUnion(frame1, frame2);
UIView *view1 = [[UIView alloc] initWithFrame:frame1];
[view1 setBackgroundColor:[UIColor redColor]];
UIView *view2 = [[UIView alloc] initWithFrame:frame2];
[view2 setBackgroundColor:[UIColor orangeColor]];
UIView *view3 = [[UIView alloc] initWithFrame:frame3];
[view3 setBackgroundColor:[UIColor grayColor]];
[self.view addSubview:view3];
[self.view addSubview:view2];
[self.view addSubview:view1];

</code></pre>

<figure>
<img src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-3.jpg" alt="" />
</figure>

<h4 id="entendiendocgrectdivide">Entendiendo CGRectDivide</h4>

<pre><code>// CGRectDivide
CGRect frame = CGRectMake(10.0, 50.0, 300.0, 300.0);
CGRect part1;
CGRect part2;
CGRectDivide(frame, &amp;part1, &amp;part2, 100.0, CGRectMaxYEdge);
 
UIView *view1 = [[UIView alloc] initWithFrame:frame];
[view1 setBackgroundColor:[UIColor grayColor]];
 
UIView *view2 = [[UIView alloc] initWithFrame:part1];
[view2 setBackgroundColor:[UIColor orangeColor]];
 
UIView *view3 = [[UIView alloc] initWithFrame:part2];
[view3 setBackgroundColor:[UIColor redColor]];
 
[self.view addSubview:view1];
[self.view addSubview:view2];
[self.view addSubview:view3];
</code></pre>

<figure>
<img src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-4.jpg" alt="" />
</figure>

<h4 id="transform">Transform</h4>

<p>Las vistas pueden ser escaladas, rotadas y traladadas. Esto se hace con las transformaciones.
Las transformaciones están definidas madiante la matriz de transformación </p>

<pre><code>struct CGAffineTransform {
   CGFloat a;
   CGFloat b;
   CGFloat c;
   CGFloat d;
   CGFloat tx;
   CGFloat ty;
};


|  a   b   0  |
|  c   d   0  |
| tx  ty   1  |

</code></pre>

<p>A cada punto de la vista se le aplica la transformación según la matriz, siguiendo este calculo:</p>

<pre><code>new x position = old x position * a + old y position * c + tx
new y position = old x position*b + old y position * d + ty
</code></pre>

<p>Para hacer transformaciones de una vista usando la matriz:</p>

<pre><code>CGAffineTransformMake
CGAffineTransformMakeRotation
CGAffineTransformMakeScale
CGAffineTransformMakeTranslation
</code></pre>

<p>Para hacer modificaciones de una transformación:</p>

<pre><code>CGAffineTransformTranslate
CGAffineTransformScale
CGAffineTransformRotate
CGAffineTransformInvert
CGAffineTransformConcat
</code></pre>

<p>Por ejemplo <code>view.transform = CGAffineTransformMakeTranslation(2.0, 2.0);</code> hace lo mismo que esto <code>view.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 2.0, 2.0);</code> ya que en el segundo caso estoy aplicando una transformación sobre <code>CGAffineTransformIdentity</code> que representa la matrix identidad sin cambios.</p>

<p>Para concatenar transformaciones, habría que usar lo métodos de modificación de transformaciones, estableciendo como transformación de partida la anterior:</p>

<pre><code>view.transform = CGAffineTransformTranslate(view.transform, 5.0, 10.0);
view.transform = CGAffineTransformRotate(view.transform, degreesToRadians(45)); 
view.transform = CGAffineTransformScale(view.transform, 2.0, 2.0);
</code></pre>

<p>Ejercicio: Aplicar la transformación de la imagen a un rectángulo de 100x100</p>

<figure>
<img src="http://f.cl.ly/items/3E381u0p140W291D1d2L/Image%202014-06-16%20at%2012.34.45%20p.m..png" alt="" />
</figure>

<pre><code>- (void) example03{
    CGRect blueViewFrame = CGRectMake(100, 100, 100, 100);
    UIView *blueView = [[UIView alloc] initWithFrame:blueViewFrame];
    blueView.backgroundColor = [UIColor blueColor];
    [self.view addSubview:blueView];
    blueView.transform = CGAffineTransformMake(1, 0, -0.4, 1, 0, 0);
}
</code></pre>

<h4 id="subclassinguiview">Subclassing UIView</h4>

<p>Como ejemplo de subclase de UIView vamos a crearnos nuestro propio botón <em>MyButton</em> personalizado. Vamos a encargarnos de implementar un método inicializador, del dibujado y de la respuesta a eventos:</p>

<pre><code>@interface MyButton : UIView

@property (nonatomic, copy) NSString *title;

- (id) initWithFrame:(CGRect)frame title:(NSString *) theTitle color:(UIColor *) fillColor;

@end
</code></pre>

<p>En la implementación:</p>

<pre><code>@property (nonatomic, strong) UIView * shadow;
...

- (id)initWithFrame:(CGRect)frame
{
    return [self initWithFrame:frame title:@&quot;Button&quot; color:[UIColor greenColor]];
}

- (id) initWithFrame:(CGRect)frame title:(NSString *) theTitle color:(UIColor *) fillColor{
    self = [super initWithFrame:frame];
    if(self){
        _title = theTitle;
        self.backgroundColor = fillColor;
        [self setup];
    }
    return self;
}


- (void) setup{
    UILabel *buttonTitle = [[UILabel alloc] initWithFrame:CGRectInset(self.bounds, 10, 10)];
    buttonTitle.text = self.title;
    buttonTitle.textColor = [UIColor whiteColor];
    buttonTitle.textAlignment = NSTextAlignmentCenter;
    [self addSubview:buttonTitle];
    
    CGFloat shadowHeight = 5;
    self.shadow = [[UIView alloc] initWithFrame:CGRectMake(0, self.bounds.size.height - shadowHeight, self.bounds.size.width, shadowHeight)];
    self.shadow.backgroundColor = [UIColor blackColor];
    self.shadow.alpha = 0.2;
    [self addSubview:self.shadow];
    
}
</code></pre>

<p>En el controlador principal creamos una instancia:</p>

<pre><code>#import &quot;MyButton.h&quot;

...

-(void) example04{
    MyButton * myButton = [[MyButton alloc] initWithFrame:CGRectMake(20, 100, 240, 40) title:@&quot;My Button 1&quot; color:[UIColor colorWithRed:0.412 green:0.156 blue:0.350 alpha:1.000]];
    [self.view addSubview:myButton];
}

</code></pre>

<figure>
<img src="http://f.cl.ly/items/2S3l0v3Y1r2B061g1Y17/Image%202014-06-16%20at%201.09.17%20p.m..png" alt="" />
</figure>

<p>Para que responda a gestos, en el controllador de mi MyButton:</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    self.shadow.frame = self.bounds;
    NSLog(@&quot;Tocado&quot;);
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{
    CGFloat shadowHeight = 5;
    self.shadow.frame = CGRectMake(0, self.bounds.size.height - shadowHeight, self.bounds.size.width, shadowHeight);
}
</code></pre>

<h4 id="gestosmultitáctiles">Gestos Multitáctiles</h4>

<p>Para ver un ejemplo de gestos multitáctiles, vamos a hacer un ejercicio en el que nos creamos una subclase de UIView, por ejemplo <code>MultipleTouchView</code>, que permita los gestos multitáctiles y que dibuje un recuadro rojo en aquellos puntos que toquemos en la pantalla:</p>

<pre><code>#import &quot;MultipleTouchView.h&quot;

@implementation MultipleTouchView

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        [self setMultipleTouchEnabled:YES];
    }
    return self;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    //Borramos lo que ya haya
    for (UIView *view in [self subviews]) {
        [view removeFromSuperview];
    }
    
    [touches enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
        UITouch *touch = obj;
        CGPoint touchPoint = [touch locationInView:self];
        
        UIView *touchView = [[UIView alloc] init];
        [touchView setBackgroundColor:[UIColor redColor]];
        touchView.frame = CGRectMake(touchPoint.x, touchPoint.y, 30, 30);
        [self addSubview:touchView];
    }];
    
}


@end
</code></pre>

<p>En nuestro controlador principal, lo instanciamos:</p>

<pre><code>-(void) example05{
    MultipleTouchView * myMultipleTouchView = [[MultipleTouchView alloc] initWithFrame:self.view.bounds];
    [self.view addSubview:myMultipleTouchView];
}
</code></pre>

<h4 id="drag">Drag</h4>

<p>Para entender como funciona el gesto de arrastrar, vamos a hacer un ejercicio. Consiste en crear una vista, que dibuje un recuadro rojo allá donde pulse y que se desplace por donde arrastre el dedo:</p>

<pre><code>@property (nonatomic, strong) UIView * dragView;

...

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        
        [self setMultipleTouchEnabled:YES];
    }
    return self;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    if([touches count] == 1){
        UITouch *touch = [touches anyObject];
        CGPoint touchPoint = [touch locationInView:self];
        
        for(UIView * view in [self subviews]){
            if(CGRectContainsPoint(view.frame, touchPoint)){
                self.dragView = view;
                return;
            }
        }
        
        UIView *touchView = [[UIView alloc] init];
        [touchView setBackgroundColor:[UIColor redColor]];
        CGFloat size = 60;
        touchView.frame = CGRectMake(touchPoint.x - size/2, touchPoint.y - size/2, size, size);
        [self addSubview:touchView];
        self.dragView = touchView;

    }
    
    
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    self.dragView.center = [touch locationInView:self];
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    self.dragView.center = [touch locationInView:self];
}
</code></pre>

<p><em>Nota: Si pulso sobre un recuadro que ya existía, éste será el que se arrastre.</em></p>

<h4 id="autolayout:">Autolayout:</h4>

<p>Todo lo que necesitas saber de autolayouts <a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">aquí</a>.</p>

<p>Cuando queremos animar una vista cuyas dimensiones vienen definidas por <em>contrains</em>, hay que hacer las animaciones sobre esas <em>contrains</em>.</p>

<p>Vamos a ver la manipulación de <em>contrains</em> por código.</p>

<p>Ejemplo, añadir un label a 100 punto de altura:</p>

<pre><code>- (void) addLabels{
    UILabel * myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)];
    myLabel.text = @&quot;This is my label&quot;;
    myLabel.font = [UIFont systemFontOfSize:18];
    myLabel.backgroundColor = [UIColor lightGrayColor];
    myLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:myLabel];
    
    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@&quot;V:|-offsetTop-[myLabel]&quot; options:0 metrics:@{@&quot;offsetTop&quot;: @100} views:NSDictionaryOfVariableBindings(myLabel)]];
}
</code></pre>

<p>Un label centrado respecto al padre:</p>

<pre><code>- (void) addLabels{
    UILabel * myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)];
    myLabel.text = @&quot;This is my label&quot;;
    myLabel.font = [UIFont systemFontOfSize:18];
    myLabel.backgroundColor = [UIColor lightGrayColor];
    myLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:myLabel];
    
    NSLayoutConstraint * unaConstrain = [NSLayoutConstraint constraintWithItem:myLabel
                                                                     attribute:NSLayoutAttributeCenterX
                                                                     relatedBy:NSLayoutRelationEqual
                                                                        toItem:self.view
                                                                     attribute:NSLayoutAttributeCenterX
                                                                    multiplier:1
                                                                      constant:0];
    
    [self.view addConstraint: unaConstrain];
 
}

</code></pre>

<p>Animando una constrain:</p>

<pre><code>@property (nonatomic, strong) NSLayoutConstraint * myConstrain;

...

- (IBAction)anima:(id)sender {
    
    self.myConstrain = [NSLayoutConstraint constraintWithItem:self.myLabel
                                                    attribute:NSLayoutAttributeTop
                                                    relatedBy:NSLayoutRelationEqual
                                                       toItem:self.view
                                                    attribute:NSLayoutAttributeTop
                                                   multiplier:1
                                                     constant:150];
    
    [self.view addConstraint: self.myConstrain];
    
    [UIView animateWithDuration:0.5 animations:^{
        self.myConstrain.constant = 300;
        [self.view layoutIfNeeded];
    }];

}

</code></pre>

<p><strong>Trucos:</strong></p>

<ul>
<li><p>Un truco rápido para modificar el valor de una <em>constrain</em> dependiendo de la orientación:</p></li>
<li>Arrastra el <em>constrain</em> (de la lista de <em>contrains</em>) hacia el código.

<ul>
<li>!!Poner codigo necesario!!</li>
</ul></li>
<li><p>Un truco para fijar el ancho de varias vistas porcentualmente usando <em>autolayout</em>:</p>

<ul>
<li>Seleccionar ambos.</li>
<li>Poner el mismo ancho: <em>0 puntos</em></li>
<li>Y en el <em>Multiplier</em> poner la proporción, para <em>30%</em> y <em>70%</em> habría que poner <code>3/7</code></li>
</ul></li>
<li>Un trupo para usar <em>autolayout</em> en las <em>scrollView</em>:

<ul>
<li>Poner el <em>scrollView</em> con las dimensiones que se necesite fijadas con <em>contrains</em></li>
<li>Crear una subvista de tipo <code>UIView</code>, cuyas dimensiones determinarán el <code>contentSize</code> del <em>scrollView</em>.</li>
</ul></li>
</ul>

<h3 id="drawing">Drawing</h3>

<p>Siguiendo la estructura del proyecto de ayer, empezamos con los ejercicios de dibujado.</p>

<p>Ejercicio: Muestra un mosaico centrado con 3x3 repeticiones de un icono, centrado:</p>

<figure>
<img src="http://f.cl.ly/items/3Y1i0L0u2B3I3U122q01/Image%202014-06-17%20at%2010.29.10%20a.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<pre><code>- (void) example01{
    UIImage *image = [UIImage imageNamed:@&quot;Icon-60&quot;];
    UIImage *imageTiled = [image resizableImageWithCapInsets:UIEdgeInsetsZero
                                                resizingMode:UIImageResizingModeTile];
    UIImageView *iView = [[UIImageView alloc]initWithImage:imageTiled];
    [self.view addSubview:iView];
    
    CGFloat alto = image.size.width * 3;
    iView.frame = CGRectMake(100, 200, alto, alto);
    iView.center = self.view.center;
    
}

</code></pre>

<p>Nota: Con CapInsets, estamos definiendo unos margenes, dentro del cual se establece el area que se repetirá con Tile.</p>

<p>Ejercicio: Repetir verticalmente la parte central del icono anterior</p>

<figure>
<img src="http://f.cl.ly/items/3U2G210G3z202H000W0u/Image%202014-06-17%20at%2010.42.04%20a.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<pre><code>- (void) example02{
    UIImage *image = [UIImage imageNamed:@&quot;Icon-60&quot;];
    UIEdgeInsets miCorte = UIEdgeInsetsMake(30, 0, 29, 0);
    UIImage *imageTiled = [image resizableImageWithCapInsets:miCorte resizingMode:UIImageResizingModeTile];
    UIImageView *iView = [[UIImageView alloc]initWithImage:imageTiled];
    [self.view addSubview:iView];
    CGRect fr = iView.frame;
    fr.size.height *= 3;
    iView.frame = fr;
    iView.center = self.view.center;
}

</code></pre>

<p>Otra forma de hacer esta técnica &#8220;Slicing&#8221;, es usando la herramienta de Xcode</p>

<figure>
<img src="http://f.cl.ly/items/0C0E1E0M3S2S1M1Q2B3l/Image%202014-06-17%20at%2010.55.49%20a.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<p>Si queremos crear una animación basada en varios fotogramas de imágenes:</p>

<pre><code> NSArray *imageNames = @[@&quot;win_1.png&quot;, @&quot;win_2.png&quot;, @&quot;win_3.png&quot;, @&quot;win_4.png&quot;,
                        @&quot;win_5.png&quot;, @&quot;win_6.png&quot;, @&quot;win_7.png&quot;];

NSMutableArray *images = [[NSMutableArray alloc] init];
for (int i = 0; i &lt; imageNames.count; i++) {
    [images addObject:[UIImage imageNamed:[imageNames objectAtIndex:i]]];
}

UIImageView *animationImageView = [[UIImageView alloc] initWithFrame:CGRectMake(60, 95, 86, 193)];
animationImageView.animationImages = images;
animationImageView.animationDuration = 0.5;

[self.view addSubview:animationImageView];
[animationImageView startAnimating];

</code></pre>

<p>Ejemplo sacado de: <a href="http://www.appcoda.com/ios-programming-animation-uiimageview/">http://www.appcoda.com/ios-programming-animation-uiimageview/</a></p>

<h4 id="contextos">Contextos</h4>

<blockquote>
<p>Es la hoja de papel que usamos para dibujar.</p>
</blockquote>

<p>Para <code>UIImageView</code> Cocoa nos da el contexto con el método <code>- (void)drawRect:(CGRect)rect</code>.</p>

<p>Tenemos dos herramientas <code>UIKit</code> y <code>CoreGraphics</code>:</p>

<ul>
<li>UIKit solo puede dibujar sobre el contexto actual.</li>
<li>CoreGraphics es un kit completo de dibujo.</li>
</ul>

<p>Ejercicio: Dibujar la mitad derecha del icono</p>

<figure>
<img src="http://f.cl.ly/items/3m2C0k2y2q1X403M3p2F/Image%202014-06-17%20at%2012.12.39%20p.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<pre><code>- (void) example03{
    UIImage *image = [UIImage imageNamed:@&quot;Icon-60&quot;];
    CGSize size = CGSizeMake(image.size.width/2, image.size.height);
    UIGraphicsBeginImageContext(size);
    [image drawAtPoint:CGPointMake(-image.size.width/2, 0) ];
    UIImage *drawingImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    UIImageView *iView = [[UIImageView alloc]initWithImage:drawingImage];
    iView.center = self.view.center;
    [self.view addSubview:iView];
}
</code></pre>

<h4 id="blur">Blur</h4>

<p>Se usan clases externas para hacer el efecto <em>blur</em>. Descargar <a href="https://github.com/rafaparadela/UIImage-ImageEffects">aquí</a>.</p>

<p>Ejercicio: Difuminar una captura de pantalla que simule que el efecto traslúcido:</p>

<pre><code>@property (nonatomic, strong) UIImageView * screenShot;

...

- (IBAction)blur:(id)sender {
    [self presentBlurredScreenshot];
    
}

- (void) presentBlurredScreenshot{
    if (!self.screenShot){
        self.screenShot = [[UIImageView alloc] initWithFrame:self.view.frame];
    }
    self.screenShot.image =  [self blurredScreenshot];
    [self.navigationController.view addSubview:self.screenShot];
}


- (UIImage *) blurredScreenshot{
    UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, NO, 0);
    [self.navigationController.view drawViewHierarchyInRect:self.view.frame afterScreenUpdates:NO];
    UIImage *snapshotImage = UIGraphicsGetImageFromCurrentImageContext();
    UIImage *blurredSnapshotImage = [snapshotImage applyLightEffect];
    UIGraphicsEndImageContext();
    return blurredSnapshotImage;
}

</code></pre>

<h4 id="filters">Filters</h4>

<p>Pendiente. Mientras tanto leer <a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">esto</a>.</p>

<h4 id="uibezierpath">UIBezierPath</h4>

<p>Pendiente. Mientras tanto leer <a href="http://code-and-coffee.blogspot.com.es/2013/07/introduction-to-core-graphics-and_12.html">esto</a></p>

<h3 id="layers">Layers</h3>

<p>Empezamos con un acercamiento a las capas. Nada como un ejercicio para comprender algunos conceptos:</p>

<hr />

<p>Ejercicio del reloj: Consiste en dibujar una reloj cuya aguja gire cuando hacemos drag en la pantalla.</p>

<figure>
<img src="http://f.cl.ly/items/0S1z3U113I0G0d3q3t21/Image%202014-06-27%20at%204.42.21%20p.m..png" alt="" />
</figure>

<p>Solución:</p>

<ul>
<li>Creamos <em>Arrow</em>, subclase de <code>UIVIew</code> y dibujamos la flecha con un <code>UIBezierPath</code>:</li>
</ul>

<pre><code>#import &quot;Arrow.h&quot;

@implementation Arrow

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        // Initialization code
        self.backgroundColor = [UIColor clearColor];
    }
    return self;
}

- (void)drawRect:(CGRect)rect
{
    // Drawing code
    UIBezierPath* p = [UIBezierPath bezierPath];
    [p moveToPoint:CGPointMake(20,100)];
    [p addLineToPoint:CGPointMake(20, 19)];
    [p setLineWidth:20];
    [p stroke];
    // point of the arrow
    [[UIColor colorWithRed:0.979 green:0.493 blue:0.174 alpha:1.000] set];
    [p removeAllPoints];
    [p moveToPoint:CGPointMake(0,25)];
    [p addLineToPoint:CGPointMake(20, 0)];
    [p addLineToPoint:CGPointMake(40, 25)];
    [p fill];
    // snip out triangle in the tail
    [p removeAllPoints];
    [p moveToPoint:CGPointMake(10,101)];
    [p addLineToPoint:CGPointMake(20, 90)];
    [p addLineToPoint:CGPointMake(30, 101)];
    [p fillWithBlendMode:kCGBlendModeClear alpha:1.0];
}
</code></pre>

<ul>
<li>Ahora creamos una clase <em>Clock</em>, también subclase de <code>UIView</code>, que tenga un Arrow como propiedad:</li>
</ul>

<pre><code>...
@property (nonatomic, strong) Arrow * arrow;
...
- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        // Initialization code
        [self addArrow];
        self.backgroundColor = [UIColor clearColor];
    }
    return self;
}

- (void) addArrow{
    self.arrow = [[Arrow alloc] initWithFrame:CGRectMake(0, 0, 40, 100)];
    [self addSubview:self.arrow];
    self.arrow.layer.anchorPoint = CGPointMake(0.5, 1);
    self.arrow.layer.position = self.center;
}

</code></pre>

<ul>
<li>Dibujamos el reloj:</li>
</ul>

<pre><code>- (void)drawRect:(CGRect)rect
{
    //// Color Declarations
    UIColor* color = [UIColor colorWithRed:0.683 green:0.798 blue:0.903 alpha:1.000];
    UIColor* color2 = [UIColor colorWithRed:0.979 green:0.493 blue:0.174 alpha:1.000];
    
    CGRect r = CGRectMake(0, 0, 300, 300);
    r.origin = CGPointMake(self.center.x - r.size.width/2, self.center.y - r.size.height/2);
    
    //// Oval Drawing
    UIBezierPath* ovalPath = [UIBezierPath bezierPathWithOvalInRect: r];
    [color setFill];
    [ovalPath fill];
    [color2 setStroke];
    ovalPath.lineWidth = 1;
    [ovalPath stroke];
}
</code></pre>

<ul>
<li>Y transformamos la capa de arrow dependiendo de los &#8220;touches&#8221;, gestos táctiles.</li>
</ul>

<pre><code>...
@interface Clock(){
    CGPoint _previousTouch;
}
...
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    _previousTouch = [touch locationInView:self];
}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    
    CGPoint currentTouch = [touch locationInView:self];
    CGFloat amount = currentTouch.y - _previousTouch.y;
    
    self.arrow.layer.transform = CATransform3DRotate(self.arrow.layer.transform, amount*0.1, 0, 0, 1);
    
    _previousTouch = currentTouch;
    [self setNeedsDisplay];
    
}
</code></pre>

<h3 id="cascrolllayer">CAScrollLayer</h3>

<p><code>CAScrollLayer</code> es un tipo especial de capa que muestra una porción de la vista que te permite mostrar otros puntos haciendo scroll. </p>

<p>Ejercicio: Crear un <code>CAScrollLayer</code> que tenga dos subvistas (UIImage) muestre una imagen y al pulsar un botón haga scroll de una a otra:</p>

<figure>
<img src="http://f.cl.ly/items/1E132r183U0R00123s1d/gif1.gif" alt="" />
</figure>

<p>Solución:</p>

<ul>
<li>Añadimos dos propiedades, una CAScrollLayer y otro</li>
</ul>

<pre><code>@property (nonatomic, strong) CAScrollLayer * scrollLayer;
@property (weak, nonatomic) IBOutlet UIButton *myButton;
</code></pre>

<ul>
<li>Inicializamos el scroll layer y nos aseguramos que el botón siempre esté por encima:</li>
</ul>

<pre><code>self.scrollLayer  = [CAScrollLayer layer];
self.scrollLayer.bounds = CGRectMake(0, 0, self.view.bounds.size.width * 2,self.view.bounds.size.height);
self.scrollLayer.backgroundColor = [UIColor colorWithRed:0.533 green:1.000 blue:0.851 alpha:1.000].CGColor;
self.scrollLayer.anchorPoint = CGPointMake(0, 0);
self.scrollLayer.position = CGPointMake(0, 0);
[self.view.layer insertSublayer:self.scrollLayer below:self.myButton.layer];
</code></pre>

<ul>
<li>Añadimos las subvistas:</li>
</ul>

<pre><code>    CALayer *lay1 = [CALayer layer];
    UIImage *im1 = [UIImage imageNamed:@&quot;dog&quot;];
    lay1.bounds = CGRectMake(0, 0, 100, 100);
    lay1.contentsGravity = kCAGravityResizeAspectFill;
    lay1.position = CGPointMake(self.scrollLayer.bounds.size.width/4, self.scrollLayer.bounds.size.height/2);
    lay1.contents = (id)im1.CGImage;
    [self.scrollLayer addSublayer:lay1];
    
    CALayer *lay2 = [CALayer layer];
    UIImage *im2 = [UIImage imageNamed:@&quot;programmer&quot;];
    lay2.bounds = CGRectMake(0, 0, 100, 100);
    lay2.contentsGravity = kCAGravityResizeAspectFill;
    lay2.position = CGPointMake(3*self.scrollLayer.bounds.size.width/4, self.scrollLayer.bounds.size.height/2);
    lay2.contents = (id)im2.CGImage;
    [self.scrollLayer addSublayer:lay2];
    
    [self.scrollLayer scrollPoint:CGPointMake(0, 0)];
</code></pre>

<ul>
<li>Al botón le asignamos un <code>IBAction</code> para hacer <em>scroll</em>:</li>
</ul>

<pre><code>- (IBAction)goSwitch:(id)sender {
    
    if(self.myButton.tag == 0){
        [self.scrollLayer scrollToPoint:CGPointMake(self.view.bounds.size.width, 0)];
        self.myButton.tag = 1;
    }
    else{
        [self.scrollLayer scrollToPoint:CGPointMake(0, 0)];
        self.myButton.tag = 0;
    }
    
}
</code></pre>

<h4 id="unasencillaanimación:">Una sencilla animación:</h4>

<p>Ejercicio: Vamos a dibujar un UIBezierPath y vamos a animar su borde.</p>

<figure>
<img src="http://f.cl.ly/items/293M2Q103t2I3B2Z0R1w/gif2.gif" alt="" />
</figure>

<p>Solución:</p>

<pre><code>CAShapeLayer *cLayer = [CAShapeLayer layer];
    cLayer.bounds = CGRectMake(0, 0, 100, 100);
    cLayer.path = [self drawPath].CGPath;
    cLayer.lineWidth = 3;
    cLayer.fillColor = [UIColor clearColor].CGColor;
    cLayer.strokeColor = [UIColor colorWithRed:0.976 green:1.000 blue:0.182 alpha:1.000].CGColor;
    cLayer.anchorPoint = CGPointMake(0.5, 0.5);
    cLayer.position = self.view.center;
    [self.scrollLayer addSublayer:cLayer];
    
    cLayer.strokeEnd = 1;
    
    CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];
    anim.duration = 2;
    anim.fromValue = @0.0;
    anim.toValue = @1;
    [cLayer addAnimation:anim forKey:@&quot;stroke&quot;];
</code></pre>

<h4 id="jugandocongradientes">Jugando con gradientes</h4>

<p>Un ejercicio para colorear una capa con gradiente.</p>

<figure>
<img src="http://f.cl.ly/items/3L2a260Z3j3X3U3T3O0j/Image%202014-06-27%20at%205.36.00%20p.m..png" alt="" />
</figure>

<pre><code>CAGradientLayer *gLayer = [CAGradientLayer layer];
gLayer.bounds = CGRectMake(0, 0, 200, 200);
gLayer.position = self.view.center;
gLayer.colors = @[(id)[UIColor colorWithRed:0.510 green:1.000 blue:0.147 alpha:1.000].CGColor,
                      (id)[UIColor colorWithRed:1.000 green:0.948 blue:0.172 alpha:1.000].CGColor,
                      (id)[UIColor colorWithRed:1.000 green:0.425 blue:0.122 alpha:1.000].CGColor];
    
gLayer.locations = @[ @0.0, @0.3, @1];
gLayer.startPoint = CGPointMake(0, 0);
gLayer.endPoint = CGPointMake(1, 1);
gLayer.type = @&quot;radial&quot;;
[self.scrollLayer addSublayer:gLayer];
</code></pre>

<h3 id="animation">Animation</h3>

<p>Encaramos unos ejercicios de animaciones de la mano de <a href="https://twitter.com/foolonhill">Ricardo Sanchez</a>. </p>

<h5 id="uiimageviewanimation">UIImageView Animation</h5>

<p>Ejercicio: Dados una secuencia de imágenes/fotogramas componer una animación, que se inicie cuando se pulsa un botón y se para cuando se pulsa otro.</p>

<figure>
<img src="http://f.cl.ly/items/2I3I100q0e2w243a0h3Z/gif3.gif" alt="" />
</figure>

<pre><code>@property (weak, nonatomic) IBOutlet UIImageView *imageView;

...

NSMutableArray * aux = [[NSMutableArray alloc] init];
    
for (int i=1; i&lt;=12; i++) {
    NSString *nombre = [NSString stringWithFormat:@&quot;pollo%04d&quot;,i];
    UIImage *img = [UIImage imageNamed:nombre];
    [aux addObject:img];
}
    
self.imageView.animationImages = aux.copy;
self.imageView.animationDuration = 0.4;

...

[self.imageView startAnimating];

...

[self.imageView stopAnimating];
</code></pre>

<hr />

<p>Ejercicio: Animar el color de fondo de un UIView:</p>

<pre><code>self.myView = [[UIView alloc] initWithFrame:CGRectMake(40, 40, 100, 100)];
self.myView.backgroundColor = [UIColor redColor];
[self.view addSubview:self.myView];

[UIView animateWithDuration:2.0 animations:^{
    self.myView.layer.backgroundColor = [UIColor blueColor].CGColor;
}];
</code></pre>

<hr />

<p>Ejercicio: Encadenar dos animaciones con completion:</p>

<pre><code>- (void) buttonPressed{
    
    [UIView animateWithDuration:1.0 animations:^{
        
        self.myView.layer.bounds = CGRectMake(40, 40, 200, 200);
        self.myView.center = CGPointMake(140, 140);
        
    } completion:^(BOOL finished) {
        
        [UIView animateWithDuration:2.0 animations:^{
            self.myView.layer.backgroundColor = [UIColor blueColor].CGColor;
            
        }];
        
    }];
    
}

</code></pre>

<h6 id="opcionesdeanimación:">Opciones de animación:</h6>

<ul>
<li><code>UIViewAnimationOptionLayoutSubviews</code></li>
<li><code>UIViewAnimationOptionAllowUserInteraction</code></li>
<li><code>UIViewAnimationOptionBeginFromCurrentState</code></li>
<li><code>UIViewAnimationOptionRepeat</code></li>
<li><code>UIViewAnimationOptionAutoreverse</code></li>
<li><code>UIViewAnimationOptionOverrideInheritedDuration</code></li>
<li><code>UIViewAnimationOptionOverrideInheritedCurve</code></li>
<li><code>UIViewAnimationOptionOverrideInheritedOptions</code></li>
<li><code>UIViewAnimationOptionAllowAnimatedContent</code></li>
</ul>

<h6 id="curvasdeanimación:">Curvas de animación:</h6>

<ul>
<li><code>UIViewAnimationOptionCurveEaseInOut</code></li>
<li><code>UIViewAnimationOptionCurveEaseIn</code></li>
<li><code>UIViewAnimationOptionCurveEaseOut</code></li>
<li><code>UIViewAnimationOptionCurveLinear</code></li>
</ul>

<h5 id="transiciones">Transiciones</h5>

<p>Las transiciones son animaciones predefinidas entre dos <code>UIView</code> con un padre común o dos estados de una sola <code>UIView</code>.</p>

<h6 id="tiposdetransiciones:">Tipos de transiciones:</h6>

<ul>
<li>UIViewAnimationOptionTransitionNone</li>
<li>UIViewAnimationOptionTransitionFlipFromLeft</li>
<li>UIViewAnimationOptionTransitionFlipFromRight</li>
<li>UIViewAnimationOptionTransitionCurlUp</li>
<li>UIViewAnimationOptionTransitionCurlDown</li>
<li>UIViewAnimationOptionTransitionCrossDissolve</li>
<li>UIViewAnimationOptionTransitionFlipFromTop</li>
<li>UIViewAnimationOptionTransitionFlipFromBottom</li>
</ul>

<hr />

<p>Ejercicio:</p>

<figure>
<img src="http://f.cl.ly/items/1n263r3W07293n2I0L21/gif4.gif" alt="" />
</figure>

<pre><code>@property (weak, nonatomic) IBOutlet UIView *v1;
@property (weak, nonatomic) IBOutlet UIView *v2;
@property (weak, nonatomic) IBOutlet UIView *vparent;

...

[UIView transitionFromView:self.v1
                        toView:self.v2
                      duration:1.0
                       options:UIViewAnimationOptionTransitionFlipFromLeft|UIViewAnimationOptionShowHideTransitionViews
                    completion:^(BOOL finished) {

    self.v2.hidden = NO;
    self.v1.hidden = YES;

}];
</code></pre>

<h5 id="animacionesconkeyframes:">Animaciones con keyframes:</h5>

<p>Ejercicio: Añadiendo Keyframes a una animación, tenemos que conseguir rotar 360* una UIView.</p>

<figure>
<img src="http://f.cl.ly/items/0O1D0A0J0H2g1Z3t3E26/gif5.gif" alt="" />
</figure>

<pre><code>- (void) gira360{

    CGFloat duration = 2.0;
    CGFloat pasos = 3.0;
    CGFloat intervalo = 1/pasos;
    NSLog(@&quot;%f %f %f&quot;, duration, pasos, intervalo);

    [UIView animateKeyframesWithDuration:duration delay:0 options:UIViewKeyframeAnimationOptionCalculationModeCubic animations:^{
        
         for (int i = 0; i&lt;pasos; i++) {
             CGFloat inicio = intervalo*i;
             [UIView addKeyframeWithRelativeStartTime:inicio relativeDuration:intervalo animations:^{
                 self.v1.transform = CGAffineTransformRotate(self.v1.transform,2*M_PI/pasos);
             }];
         }
     } completion:nil];
    
}
</code></pre>

<h3 id="coreanimation">Core Animation</h3>

<p>Animaciones de capas. Las siguientes propiedades:</p>

<p><code>anchorPoint</code> <code>borderColor</code> <code>borderWidth</code> <code>bounds</code> <code>contents</code> <code>contentsRect</code> <code>cornerRadius</code> <code>hidden</code> <code>mask</code> <code>masksToBounds</code> <code>opacity</code> <code>position</code> <code>shadowColor</code> <code>shadowOffset</code> <code>shadowOpacity</code> <code>shadowPath</code> <code>shadowRadius</code> <code>sublayers</code> <code>sublayerTransform</code> <code>transform</code> <code>zPosition</code></p>

<h5 id="cabasicanimation">CABasicAnimation</h5>

<p>Ejercicio:</p>

<figure>
<img src="http://res.cloudinary.com/rafaparadela/image/upload/v1403890858/gif6_xbjq8c.gif" alt="" />
</figure>

<pre><code>- (void) ejercicio4{
    self.vparent.hidden = YES;
    
    
    self.cLayer1 = [CAShapeLayer layer];
    self.cLayer1.bounds = CGRectMake(0, 0, 100, 100);
    self.cLayer1.path = [self drawPath1].CGPath;
    self.cLayer1.lineWidth = 3;
    self.cLayer1.fillColor = [UIColor clearColor].CGColor;
    self.cLayer1.strokeColor = [UIColor colorWithRed:0.189 green:0.552 blue:0.808 alpha:1.000].CGColor;
    self.cLayer1.anchorPoint = CGPointMake(0, 0);
    self.cLayer1.position = CGPointMake(100, 100);
    [self.view.layer addSublayer:self.cLayer1];

    self.cLayer1.strokeEnd = 0;
    CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];
    anim.duration = 2;
    anim.beginTime = 0;
    anim.fromValue = @0.0;
    anim.toValue = @1.0;
    
    [self.cLayer1 addAnimation:anim forKey:@&quot;stroke&quot;];
    
}

- (UIBezierPath *) drawPath1{
    UIBezierPath* starPath = UIBezierPath.bezierPath;
    [starPath moveToPoint: CGPointMake(41, 15)];
    [starPath addLineToPoint: CGPointMake(51.58, 30.44)];
    [starPath addLineToPoint: CGPointMake(69.53, 35.73)];
    [starPath addLineToPoint: CGPointMake(58.12, 50.56)];
    [starPath addLineToPoint: CGPointMake(58.63, 69.27)];
    [starPath addLineToPoint: CGPointMake(41, 63)];
    [starPath addLineToPoint: CGPointMake(23.37, 69.27)];
    [starPath addLineToPoint: CGPointMake(23.88, 50.56)];
    [starPath addLineToPoint: CGPointMake(12.47, 35.73)];
    [starPath addLineToPoint: CGPointMake(30.42, 30.44)];
    [starPath closePath];
    [UIColor.grayColor setFill];

    return starPath;
}
</code></pre>

<h4 id="cakeyframeanimation">CAKeyFrameAnimation</h4>

<p>Animaciones con layers con keyframes:</p>

<pre><code>- (void) buttonPressed5{
    self.cLayer1.position = CGPointMake(self.view.bounds.origin.x+50, self.view.bounds.origin.y+50);
    CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
    
    anim.values = @[[NSValue valueWithCGPoint:CGPointMake(self.view.bounds.origin.x+50, self.view.bounds.origin.y+50)],
                    [NSValue valueWithCGPoint:CGPointMake(self.view.bounds.size.width-50, self.view.bounds.origin.y+50)],
                    [NSValue valueWithCGPoint:CGPointMake(self.view.bounds.size.width-50, self.view.bounds.size.height-50)],
                    [NSValue valueWithCGPoint:CGPointMake(self.view.bounds.origin.x+50, self.view.bounds.size.height-50)],
                    [NSValue valueWithCGPoint:CGPointMake(self.view.bounds.origin.x+50, self.view.bounds.origin.y+50)]
                    ];
    
    anim.keyTimes = @[@0.05,@0.10,@0.15,@0.20,@1.0];
    anim.duration = 5;
    
    [self.cLayer1 addAnimation:anim forKey:@&quot;position&quot;];
    
}

</code></pre>

<h4 id="cakeyframeanimationconpath">CAKeyFrameAnimation con path</h4>

<pre><code>- (void) buttonPressed6{
    self.cLayer1.position = CGPointMake(self.view.bounds.origin.x+50, self.view.bounds.origin.y+50);
    CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];
    
    UIBezierPath *mypath = [UIBezierPath bezierPathWithRect:CGRectInset(self.view.bounds, 50, 50)];
                      
                      
    UIBezierPath* starPath = UIBezierPath.bezierPath;
    [starPath moveToPoint: CGPointMake(20, 20)];
    [starPath addLineToPoint: CGPointMake(300, 0)];
    [starPath addLineToPoint: CGPointMake(300, 300)];
    [starPath addLineToPoint: CGPointMake(20, 320)];
    [starPath addLineToPoint: CGPointMake(20, 20)];
    [starPath closePath];
    
    anim.path = mypath.CGPath;
    anim.duration = 5;
    
    [self.cLayer1 addAnimation:anim forKey:@&quot;position&quot;];
    
}
</code></pre>

<h5 id="caanimationgroup">CAAnimationGroup</h5>

<p>Las animaciones se pueden agrupar con <code>CAAnimationGroup</code>:</p>

<pre><code>- (void) buttonPressed4{

    CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];
    anim.duration = 1;
    anim.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, 0)];
    anim.toValue = [NSValue valueWithCGPoint:CGPointMake(100, 100)];
    self.cLayer1.position = CGPointMake(100, 100);
    [self.cLayer1 addAnimation:anim forKey:@&quot;position&quot;];
    
    CABasicAnimation *agranda = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];
    agranda.duration = 1;
    agranda.fromValue = [NSValue valueWithCATransform3D:CATransform3DRotate(self.cLayer1.transform, 0, 0, 0, 1)];
    agranda.toValue = [NSValue valueWithCATransform3D:CATransform3DRotate(self.cLayer1.transform, 1, 0, 1, 1)];
    [self.cLayer1 addAnimation:agranda forKey:@&quot;transform&quot;];
    
    CAAnimationGroup *group = [CAAnimationGroup animation];
    group.duration = 1;
    group.animations = @[anim, agranda];
    
    [self.cLayer1 addAnimation:group forKey:nil];
    
}

</code></pre>

<p><a href="http://www.migueldiazrubio.com/2013/10/28/desarrollo-ios-7-profundizando-en-core-animation-cakeyframeanimation-y-uibezierpathanimation/">Muy buen tutorial sobre Core Animation con ejemplos</a>.</p>

<h4 id="animationdelegate">Animation Delegate</h4>

<p>Hacemos ejemplo de animar la entrada y salida de un modal.</p>

<figure>
<img src="http://res.cloudinary.com/rafaparadela/image/upload/v1403892396/gif7_tc9vsk.gif" alt="" />
</figure>

<ul>
<li>Ponemos un ViewController con botón para ir al siguiente viewController:</li>
</ul>

<pre><code>- (IBAction)goFoward:(id)sender {

    SecondViewController * vc = [self.storyboard instantiateViewControllerWithIdentifier:@&quot;secondVC&quot;];
    vc.transitioningDelegate = self;
    [self presentViewController:vc animated:YES completion:nil];
}

</code></pre>

<ul>
<li>Para animar la transición, debemos indicar que el primer controlador implemente el delegado <code>UIViewControllerTransitioningDelegate</code>.</li>
<li>Para definir el tipo de animación tenemos que implementar este método:</li>
</ul>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source{
    
    return [[animacion alloc] init];

}
</code></pre>

<ul>
<li>La animación la podemos crear como una clase NSObject que extienda a <code>UIViewControllerAnimatedTransitioning</code>:</li>
</ul>

<pre><code>@interface animacion () &lt;UIViewControllerAnimatedTransitioning&gt;
</code></pre>

<ul>
<li>Con estos dos métodos que crea la animación y la duración:</li>
</ul>

<pre><code>- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext{
    
    UIViewController * mycontroller = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
    UIViewController * tocontroller = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];

    
    [[transitionContext containerView] insertSubview:tocontroller.view atIndex:100];
    tocontroller.view.layer.position = CGPointMake(500,500);
    tocontroller.view.alpha = 0;
    [UIView animateWithDuration:1.0 animations:^{
        tocontroller.view.layer.position = CGPointMake([transitionContext containerView].center.x, [transitionContext containerView].center.y);
        tocontroller.view.alpha = 1;
    } completion:^(BOOL finished) {
        [transitionContext completeTransition:YES];
    }];
 
}

- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext{
    return 1.0;
    
}
</code></pre>

<hr />

<p>Para hacer la animación con TabBar o NavigationController es más sencillo:</p>

<figure>
<img src="http://res.cloudinary.com/rafaparadela/image/upload/v1403892619/gif8_wgwrul.gif" alt="" />
</figure>

<ul>
<li>Al UITabBarViewController sea delegado de <code>&lt;UITabBarControllerDelegate&gt;</code></li>
<li>Implementa el siguiente método:</li>
</ul>

<pre><code>- (id&lt;UIViewControllerAnimatedTransitioning&gt;)tabBarController:(UITabBarController *)tabBarController animationControllerForTransitionFromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC{
    return [[animacion alloc] init];
}
</code></pre>

<h3 id="gesturesrecognizers">Gestures Recognizers</h3>

<p>Ejercicio: Al hacer tap en la pantalla, un cohete se desplaza haciendo animación.</p>

<ul>
<li>Añado el gesto en el controlador:</li>
</ul>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    UITapGestureRecognizer * mygesto = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(move:)];
    [self.view addGestureRecognizer:mygesto];
    
}
</code></pre>

<ul>
<li>Implemento el método que haga la animación:</li>
</ul>

<pre><code>- (void) move: (UIGestureRecognizer*) gesto{
    
    [UIView animateWithDuration:1 animations:^{
        self.rocket.layer.position = [gesto locationInView:self.view];
    }];
    
}
</code></pre>

<hr />

<p>Ejercicios, escalar una imagen usando gestos Pinch, que al soltar recupere el tamaño normal de la imagen:</p>

<pre><code>
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.rocket.bounds = CGRectMake(0, 0, 100, 100);
    self.rocket.center = self.view.center;

    UIPinchGestureRecognizer * myPinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(zoom:)];
    [self.view addGestureRecognizer:myPinch];
    
}

- (void) zoom: (UIPinchGestureRecognizer*) gesto{
    
    self.rocket.bounds = CGRectMake(0, 0, gesto.scale*100, gesto.scale*100);
    self.rocket.center = self.view.center;
    
    if (gesto.state== UIGestureRecognizerStateEnded) {
        
        [UIView animateWithDuration:0.5 animations:^{
            self.rocket.bounds = CGRectMake(0, 0, 100, 100); 
        }];
        
    }
}

</code></pre>

<hr />

<p>Comprobar que el tap no es un double tap. Ejercicio, hacer dos acciones dependiendo si es tap o double tap:</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];
    
    UITapGestureRecognizer * mygesto = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(choose:)];
    [self.view addGestureRecognizer:mygesto];
    
    UITapGestureRecognizer * mygesto2 = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(choose2:)];
    mygesto2.numberOfTapsRequired = 2;
    [self.view addGestureRecognizer:mygesto2];
    
    [mygesto requireGestureRecognizerToFail:mygesto2];
    
}

- (void) choose: (UITapGestureRecognizer*) gesto{
    NSLog(@&quot;tap&quot;);
}

- (void) choose2: (UITapGestureRecognizer*) gesto{
    NSLog(@&quot;double tap&quot;);
}
</code></pre>

<p>Dobles gestos reconocidos:</p>

<pre><code>@interface RocketViewController () &lt;UIGestureRecognizerDelegate&gt;

...

- (void)viewDidLoad
{
    [super viewDidLoad];

    UIPinchGestureRecognizer * myPinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(zoom:)];
    [self.view addGestureRecognizer:myPinch];
    myPinch.delegate = self;
    
    UIRotationGestureRecognizer * myRotate = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotate:)];
    [self.view addGestureRecognizer:myRotate];

}    

- (void) zoom: (UIPinchGestureRecognizer*) gesto{
    self.rocket.transform = CGAffineTransformScale(self.rocket.transform,gesto.scale, gesto.scale);
    gesto.scale = 1;
}

- (void) rotate: (UIRotationGestureRecognizer*) gesto{
    self.rocket.transform = CGAffineTransformRotate(self.rocket.transform, gesto.rotation);
    gesto.rotation = 0;
}
</code></pre>

				  
				  				  
				  <!-- %%%%%% -->
			  </div>
			  
			  
			  <div class="bs-docs-section" id="w04-section">
				  <h1 id="w04" class="page-header">Semana 4</h1>
				  
				  <!-- &&&&&& -->
				  
				  
<p>Empezamos la semana con la presentación de un nuevo profesor: <a href="https://twitter.com/fillito">Daniel García</a>.</p>

<h2 id="modelos">Modelos</h2>

<p>Creamos una clase TVshow y otra Movie, con propiedades, que cumpla NSCopying e implementamos <code>(id)copyWithZone:(NSZone *)zone</code>.</p>

<pre><code>@interface TVshow : NSObject&lt;NSCopying, NSCoding&gt;
@property (nonatomic, copy) NSString* id;
@property (nonatomic, copy) NSString* title;
@property (nonatomic, copy) NSString* description;
@property (nonatomic, assign) CGFloat rating;
@end
</code></pre>

<p>Nota: por que algunas property es strong/copy. Cuando una propiedad de una entidad tiene versión mutable, debería usar copy y no strong.</p>

<pre><code>- (id)copyWithZone:(NSZone *)zone{
    Movie * movieCopy = [[[self class] allocWithZone:zone] init];
    if(movieCopy){
        //Objects
        movieCopy.id = [self.id copyWithZone:zone];
        movieCopy.title = [self.title copyWithZone:zone];
        movieCopy.description = [self.description copyWithZone:zone];
        
        //Scalars
        movieCopy.rating = self.rating;
    }
    return movieCopy;
}
</code></pre>

<p>Y un ejemplo de cómo se copiaría el ultimo elemento del array:</p>

<pre><code>
- (IBAction)copyLast:(id)sender {
    
    if([self.myshows count] &gt; 0){
        TVshow * copyshow = [[self.myshows lastObject] copy];
        [self.myshows addObject:copyshow];
        [self.tableView reloadData];
    }
    
}
</code></pre>

<p>Y también implementa el protocolo NSCoding, si quisiera guardar ciertos objetos en disco.</p>

<pre><code>- (id)initWithCoder:(NSCoder *)aDecoder{
    self = [super init];
    if(self) {
        _id = [aDecoder decodeObjectForKey:@&quot;id&quot;];
        _title = [aDecoder decodeObjectForKey:@&quot;title&quot;];
        _description = [aDecoder decodeObjectForKey:@&quot;description&quot;];
        _rating = [aDecoder decodeIntegerForKey:@&quot;rating&quot;];
    }
    return self;
}


- (void)encodeWithCoder:(NSCoder *)aCoder{
    [aCoder encodeObject:self.id forKey:@&quot;id&quot;];
    [aCoder encodeObject:self.title forKey:@&quot;title&quot;];
    [aCoder encodeObject:self.description forKey:@&quot;description&quot;];
    [aCoder encodeInteger:self.rating forKey:@&quot;rating&quot;];
}
</code></pre>

<p>Y un ejemplo de cómo se guardaría en disco:</p>

<pre><code>static NSString * const savedShowsFileName=@&quot;shows&quot;;

...

- (void) save{
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
    NSString * documentsDirectory = [paths objectAtIndex:0];
    NSString * myfilename = [documentsDirectory stringByAppendingString:savedShowsFileName];
    
    if (self.myshows.count) {
        [NSKeyedArchiver archiveRootObject:self.myshows toFile:myfilename];
    }
}
</code></pre>

<h3 id="comparación">Comparación</h3>

<p>Para comparar tenemos que usar algunas buenas practicas:</p>

<p>1.- <code>isEqualTo[misma clase]</code> donde definimos los criterios que queramos que sean estudiados para saber si es igual.</p>

<pre><code>- (BOOL)isEqualToTVshow:(TVshow *)show{
    if(![self.id isEqualToString:show.id]){
        return NO;
    }
    return YES;
}
</code></pre>

<p>2.- <code>isEqual</code>, comprobar si no es el mismo objeto, si es de otro tipo y luego llamar al metodo anterior.</p>

<pre><code>- (BOOL)isEqual:(TVshow *)show{
    if(self == show){
        return YES;
    }
    if(![show isKindOfClass:[self class]]){
        return NO;
    }
    return [self isEqualToTVshow:show];
}
</code></pre>

<ul>
<li><code>hash</code> hash is a unique identifier (NSUInteger)</li>
</ul>

<pre><code>- (NSUInteger)hash{
    return [_id hash];
}
</code></pre>

<h3 id="lomismoperousandomantle:">Lo mismo pero usando Mantle:</h3>

<p>Explicar qué es mantle.</p>

<p>En nuestra clase, que sea subclase de MTLModel</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &lt;Mantle/Mantle.h&gt;

@interface TVshow : MTLModel
@property (nonatomic, copy) NSString* id;
@property (nonatomic, copy) NSString* title;
@property (nonatomic, copy) NSString* description;
@property (nonatomic, assign) CGFloat rating;
@end
</code></pre>

<h3 id="serializarunjsonconmantle">Serializar un JSON con Mantle</h3>

<p>Tenemos que implementar el método de clase:</p>

<pre><code>+ (NSDictionary *)JSONKeyPathsByPropertyKey {
    return @{
             @&quot;id&quot;: @&quot;id&quot;,
             @&quot;title&quot;: @&quot;title&quot;,
             @&quot;description&quot;: @&quot;description&quot;
             };
}
</code></pre>

<p>Y desde donde quiera parsear el JSON y convertirlo a objetos:</p>

<pre><code>- (id)initWithCoder:(NSCoder *)aDecoder{
    
    self = [super initWithCoder:aDecoder];
    if (self) {
        self.title = @&quot;Series&quot;;
        _myshows = [NSMutableArray array];
        
        
        NSURL * jsonURL = [NSURL URLWithString:@&quot;http://ironhack4thweek.s3.amazonaws.com/shows.json&quot;];
        NSData * seriesData = [NSData dataWithContentsOfURL:jsonURL];
        NSError * error;
        NSDictionary * JSONDictionary = [NSJSONSerialization JSONObjectWithData:seriesData options:NSJSONReadingMutableContainers error:&amp;error];
        
        for (NSDictionary * tvshowDictionary in [JSONDictionary valueForKey:@&quot;shows&quot;]) {
            NSError * parseError;
            TVshow * showItem = [MTLJSONAdapter modelOfClass:[TVshow class] fromJSONDictionary:tvshowDictionary error:&amp;parseError];
            [_myshows addObject:showItem];
            
        }
        
        
    }
    return self;
}
</code></pre>

<h3 id="persistencia">Persistencia</h3>

<h4 id="coredata">Core Data</h4>

<p>Es un framework que nos facilita Apple, y que por debajo realmente utiliza SQL Lite, pero contamos con una serie de herramientas que nos facilita tanto la creación del modelo como su gestión posterior desde código.</p>

<p>Core Data se apoya en tres conceptos básicos:</p>

<ul>
<li>Managed Object Model: definición del modelo de datos.</li>
<li>Persistent Storage Coordinator: es el encargado de persistir la información.</li>
<li>Managed Object Context: “memoria temporal” donde poder trabajar antes de realizar la persistencia.</li>
</ul>

<h5 id="ejemplodeproyectoqueusecoredata:">Ejemplo de proyecto que use core data:</h5>

<ul>
<li>Añade al proyecto el framework</li>
</ul>

<figure>
<img src="http://f.cl.ly/items/3o013F0i3W1h3N05150D/Image%202014-06-24%20at%2010.09.17%20a.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<ul>
<li>Importa coredata en el prefix.pch</li>
</ul>

<pre><code>#ifdef __OBJC__
    #import &lt;UIKit/UIKit.h&gt;
    #import &lt;Foundation/Foundation.h&gt;
    #import &lt;CoreData/CoreData.h&gt;
#endif
</code></pre>

<ul>
<li>Vamos a crear una clase llamada &#8220;CoreDataManager&#8221;, que encapsule los métodos y propiedades que gestionen Core Data:</li>
</ul>

<figure>
<img src="http://f.cl.ly/items/0o0e3C0V0h2b1x260C2X/Image%202014-06-24%20at%2010.12.19%20a.m..png" alt="image" />
<figcaption>image</figcaption>
</figure>

<ul>
<li>En el .h creamos un contexto <code>NSManagedObjectContext</code> y el <em>designated initializer</em>:</li>
</ul>

<pre><code>@interface CoreDataManager : NSObject
@property (readonly, strong, nonatomic) NSManagedObjectContext *managedObjectContext;
- (instancetype)initWithModelName:(NSString *)modelName;
@end
</code></pre>

<ul>
<li>En el .m crea propiedades privadas que pueden ser escritas:</li>
</ul>

<pre><code>@interface CoreDataManager ()
@property (readwrite, strong, nonatomic) NSManagedObjectContext *managedObjectContext;
@property (readwrite, strong, nonatomic) NSManagedObjectModel *managedObjectModel;
@property (readwrite, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;
@end
</code></pre>

<ul>
<li>Y contendrá las implementaciones de estos métodos (copiados del AppDelegate.m):</li>
</ul>

<pre><code>- (void)saveContext
- (NSManagedObjectContext *)managedObjectContext
- (NSManagedObjectModel *)managedObjectModel
- (NSPersistentStoreCoordinator *)persistentStoreCoordinator
- (NSURL *)applicationDocumentsDirectory
</code></pre>

<ul>
<li>Sin olvidar los métodos inicializadores:</li>
</ul>

<pre><code>- (instancetype)init
{
    return [self initWithModelName:nil];
}

- (instancetype)initWithModelName:(NSString *)modelName
{
    NSAssert(modelName, @&quot;Model name is requered&quot;);
    self = [super init];
    if (self) {
        _modelName = modelName;
    }
    return self;
}
</code></pre>

<p>Para este ejemplo vamos a crear una entidad userEntity para usarla en un sistema de autenticación:</p>

<ul>
<li>Nos creamos un core data model</li>
<li>Creamos la entidad userEntity</li>
<li>Le metemos atributos</li>
</ul>

<figure>
<img src="http://f.cl.ly/items/2w0d2I2x1b2D07063T00/Captura%20de%20pantalla%202014-06-24%20a%20la(s)%2010.58.39.png" alt="image" />
<figcaption>image</figcaption>
</figure>

<ul>
<li>Creamos las clases:</li>
</ul>

<figure>
<img src="http://f.cl.ly/items/2F0n1F3A3H0V0k1h2j3n/Captura%20de%20pantalla%202014-06-24%20a%20la(s)%2010.58.39.png" alt="image" />
<figcaption>image</figcaption>
</figure>

<ul>
<li>Desde los controladores que usarán Core Data, se importa usando &#8220;Inyección de dependencias&#8221;:</li>
</ul>

<pre><code>#import &quot;CoreDataManager.h&quot;
#import &quot;UserEntity.h&quot;

...

@property (strong, nonatomic) CoreDataManager * coreDataManager;

...

- (id)initWithCoder:(NSCoder *)aDecoder
{
    self = [super initWithCoder:aDecoder];
    if (self) {
        _coreDataManager = [[CoreDataManager alloc] initWithModelName:@&quot;Shows&quot;];
        
    }
    return self;
}

</code></pre>

<p>¿Cómo se usa?</p>

<h5 id="crearentidad:">Crear entidad:</h5>

<pre><code>NSManagedObjectContext *managedObjectContext=[[NSManagedObjectContext alloc]init];
UserEntity *user = [NSEntityDescription insertNewObjectForEntityForName:@&quot;UserEntity&quot; 
inManagedObjectContext:managedObjectContext];
user.userId=@&quot;1&quot;;
user.userName=@&quot;John Appleseed&quot;;

NSError *error;
[managedObjectContext save:&amp;error];
</code></pre>

<h5 id="leerentidad:">Leer entidad:</h5>

<pre><code>- (UserEntity *)userWithId:(NSString *)userId 
inManagedObjectContext:(NSManagedObjectContext*)managedObjectContext{

    NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@&quot;UserEntity&quot;];
    fetchRequest.predicate = [NSPredicate predicateWithFormat:@“userName = %@“, userId];   
    NSError *error;
    NSArray *fetchResult=[managedObjectContext executeFetchRequest:fetchRequest error:&amp;error];
    return fetchResult.count?[fetchResult firstObject]:nil;

}
</code></pre>

<h5 id="editarentidad:">Editar entidad:</h5>

<pre><code>NSManagedObjectContext *managedObjectContext=[[NSManagedObjectContext alloc]init];
UserEntity *user = [self userWithId:@&quot;1&quot; inManagedObjectContext:managedObjectContext];

user.name=@&quot;John Doe&quot;;

NSError *error;
[managedObjectContext save:&amp;error];
</code></pre>

<h5 id="eliminarentidad:">Eliminar entidad:</h5>

<pre><code>NSManagedObjectContext *managedObjectContext=[[NSManagedObjectContext alloc]init];
UserEntity *user = [self userWithId:@&quot;1&quot; inManagedObjectContext:managedObjectContext];

[managedObjectContext deleteObject:user];

NSError *error;
[managedObjectContext save:&amp;error];
</code></pre>

<h4 id="nsuserdefaults">NSUserDefaults</h4>

<p>Podemos almacenar simples preferencias de usuario utilizando tipos de datos como NSString o NSInteger.</p>

<h5 id="escribirennsuserdefaults">Escribir en NSUserDefaults</h5>

<pre><code>NSString *currentLang=@&quot;es&quot;;
[[NSUserDefaults standardUserDefaults]setObject:currentLanguage forKey:@&quot;userConfigCurrentLang&quot;];
</code></pre>

<p>Los objetos deben ser <code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> o <code>NSDictionary</code>.</p>

<p>Otros métodos para esciribr en NSUserDefaults:</p>

<ul>
<li>setBool:forKey:</li>
<li>setFloat:forKey:</li>
<li>setInteger:forKey:</li>
<li>setDouble:forKey:</li>
<li>setURL:forKey:</li>
</ul>

<h5 id="leerdensuserdefaults">Leer de NSUserDefaults</h5>

<pre><code>NSString *currentLang;
currentLang = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;userConfigCurrentLang&quot;];
</code></pre>

<p>Otros métodos para leer de NSUserDefaults:</p>

<ul>
<li>arrayForKey:</li>
<li>boolForKey:</li>
<li>dataForKey:</li>
<li>dictionaryForKey:</li>
<li>floatForKey:</li>
<li>integerForKey:</li>
</ul>

<h5 id="sincronizarnsuserdefaults">Sincronizar NSUserDefaults</h5>

<pre><code>[[NSUserDefaults standardUserDefaults] synchronize];
</code></pre>

<h4 id="plistpropertylist">Plist (Property List)</h4>

<p>Son archivos que almacenan objetos serializados, se utilizan frecuentemente para almacenar configuraciones del usuario y no puede contener más que objetos de tipo Core Foundation o Foundation Kit porque la biblioteca no permite serializar otros tipos de objetos: <code>NSArray</code>, <code>NSDictionary</code>, <code>NSString</code>, <code>NSData</code>, <code>NSDate</code> y <code>NSNumber</code>.</p>

<h5 id="leerdeplist">Leer de plist</h5>

<pre><code>NSURL *plistURL;
NSDictionary *plistData = [NSDictionary dictionaryWithContentsOfURL:plistURL];

NSString *plistFilePath;
NSDictionary *plistData = [NSDictionary dictionaryWithContentsOfFile:plistFilePath];
</code></pre>

<h5 id="escribirplist">Escribir plist</h5>

<pre><code>NSDictionary *plistData;
NSString *plistFilePath;
[plistData writeToFile:plistFilePath atomically:YES];
</code></pre>

<h4 id="nsfilemanager">NSFileManager</h4>

<p>El framework foundation nos da acceso al sistema de ficheros para realizar operaciones básicas sobre archivos y directorios.
Ese acceso nos viene dado por NSFileManager y sus métodos incluyen la capacidad de:</p>

<ul>
<li>Crear un archivo nuevo</li>
<li>Leer desde un archivo creado</li>
<li>Escribir datos en un archivo</li>
<li>Renombrar un archivo</li>
<li>Comprobar si existe un archivo</li>
<li>Borrar un archivo</li>
<li>Listar archivos de un directorio</li>
</ul>

<h5 id="comprobarsiexisteunarchivo">Comprobar si existe un archivo</h5>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
NSString *filePath = [documentsPath stringByAppendingPathComponent:@&quot;file.txt&quot;];
BOOL fileExists = [fileManager fileExistsAtPath:filePath];
</code></pre>

<h5 id="borrarunarchivo">Borrar un archivo</h5>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *documentsPath;
NSString *filePath = [documentsPath stringByAppendingPathComponent:@&quot;image.png&quot;];

NSError *error = nil;
if (![fileManager removeItemAtPath:filePath error:&amp;error]) {
    NSLog(@&quot;[Error] %@ (%@)&quot;, error, filePath);
}
</code></pre>

<h5 id="listararchivosdeundirectorio">Listar archivos de un directorio</h5>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSURL *bundleURL = [[NSBundle mainBundle] bundleURL];
NSArray *contents = [fileManager contentsOfDirectoryAtURL:bundleURL
                               includingPropertiesForKeys:@[]
                                                  options:NSDirectoryEnumerationSkipsHiddenFiles
                                                    error:nil];

NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;pathExtension == 'png'&quot;];
for (NSURL *fileURL in [contents filteredArrayUsingPredicate:predicate]) {
    // Enumerate each .png file in directory
}
</code></pre>

<h5 id="crearnuevodirectorio">Crear nuevo directorio</h5>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *documentsPath;
NSString *imagesPath = [documentsPath stringByAppendingPathComponent:@&quot;images&quot;];
if (![fileManager fileExistsAtPath:imagesPath]) {
    [fileManager createDirectoryAtPath:imagesPath 
           withIntermediateDirectories:NO attributes:nil error:nil];
}
</code></pre>

<h5 id="leeratributosdeunarchivo">Leer atributos de un archivo</h5>

<pre><code>NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *documentsPath;
NSString *filePath = [documentsPath stringByAppendingPathComponent:@&quot;Document.pages&quot;];

if ([fileManager fileExistsAtPath:filePath]) {
    NSDictionary *attributes = [fileManager attributesOfItemAtPath:filePath error:nil];
}
</code></pre>

<h2 id="bloques">Bloques</h2>

<p>Los bloques en Objective C y Smalltalk son “trozos” de código que se pueden guardar en variables, pasar como argumentos, devolver como resultado de un mensaje y ejecutar posteriormente. Es decir, son en el fondo funciones de primer nivel (como en Lisp o cualquier lenguaje funcional), con una sintaxis algo distinta que recuerda los punteros a funciones de C.</p>

<p>Sin embargo, si sólo se tratase de eso, alguien podría decir que los bloques en Objective C son redundantes, ya que con punteros a funciones, se puede hacer todo eso en C de toda la vida, aunque resulte más farragoso y proclive a errores. Los bloques tiene algo más: capturan de forma automática el entorno léxico en el que han sido creados.</p>

<p>Esto quiere decir que si en un método definimos una variable cualquiera (digamos int i = 42) y luego definimos un bloque, dicho bloque podrá hacer referencia a dicha variable. Si pasamos ese bloque a otro objeto, seguirá pudiendo hacer referencia a dicha variable y su valor original. Más adelante veremos eso con más detalle, y su utilidad.</p>

<h5 id="anatomíadebloques">Anatomía de bloques</h5>

<pre><code>[UIView animateWithDuration:0.3 animations:^{
        self.alpha=0.0;
} completion:^(BOOL finished) {

}];
</code></pre>

<h5 id="¿cómosedeclaran">¿Cómo se declaran?</h5>

<ul>
<li>Como variable local:</li>
</ul>

<pre><code>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
</code></pre>

<ul>
<li>Como propiedad:</li>
</ul>

<pre><code>@property (nonatomic, copy) returnType (^blockName)(parameterTypes);
</code></pre>

<ul>
<li>Como parámetro:</li>
</ul>

<pre><code>- (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName;
</code></pre>

<ul>
<li>Como argumento en la llamada a un método:</li>
</ul>

<pre><code>[someObject someMethodThatTakesABlock: ^returnType (parameters) {...}];
</code></pre>

<ul>
<li>Como typedef:</li>
</ul>

<pre><code>typedef returnType (^TypeName)(parameterTypes);
TypeName blockName = ^returnType(parameters) {...};
</code></pre>

<h5 id="memoria">Memoria</h5>

<p>Los objetos referenciados dentro de un bloque son automáticamente retenidos por el bloque:</p>

<pre><code>- (void)updateHomeTownForUser:(UserEntity *)user{
    NSDate *requestDate=[NSDate date];
    [self.requestManager homeTownForUser:user completion:^(CityEntity *resultCity){
        user.hometown=resultCity;
        user.lastHometownUpdate=requestDate;
    }];
}
</code></pre>

<p><code>requestDate</code> and <code>user</code> are retained by the block</p>

<p>Misma dirección de memoria pero diferentes puntero en la pila</p>

<pre><code>NSDate *requestDate=[NSDate date]; /// 0x000001
[self.requestManager homeTownForUser:user completion:^(CityEntity *resultCity){
    user.lastHometownUpdate=requestDate; /// 0x000005
}];
</code></pre>

<p>Aunque los escalares y estructuras (<code>NSInteger</code>,<code>CGFloat</code>,<code>CGRect</code>,&#8230;) referenciados dentro del bloque se copian</p>

<h5 id="bloques≈objetos">Bloques ≈ Objetos</h5>

<p>Un bloque se puede comportar como un objeto pero nunca lo retenemos, lo copiamos:</p>

<pre><code>@interface UserFetcher()
@property (nonatomic, copy) void (^fetchUsersCallback)();
@end
- (void)fetchUsersWithCompletionBlock:(void (^)())completion{
    self.fetchUsersCallback=completion;
}
</code></pre>

<p>Ejemplo de uso: Crear un botón subclase de <code>UIBarButtonItem</code>, con un método inicializador que reciba un bloque que deba ser ejecutado en su <code>action</code>:</p>

<p><strong>En el .h</strong></p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;

typedef void (^barButtonItemBlock)();

@interface BlockButtonItem : UIBarButtonItem

- (instancetype)initWithTitle: (NSString *) title block: (barButtonItemBlock)block;

@end
</code></pre>

<p><strong>En el .m</strong></p>

<pre><code>#import &quot;BlockButtonItem.h&quot;
@interface BlockButtonItem ()
@property (copy, nonatomic) barButtonItemBlock block;
@end

@implementation BlockButtonItem

- (instancetype)initWithTitle: (NSString *) title block: (barButtonItemBlock)block
{
    self = [super initWithTitle:title style:UIBarButtonItemStylePlain target:self action:@selector(buttonAction:)];
    if (self) {
        _block = block;
    }
    return self;
}

- (void) buttonAction:(id)sender{
    self.block();
}

@end
</code></pre>

<p><strong>Al inicializar el botón le pasamos el bloque que se ejecutará</strong></p>

<pre><code>BlockButtonItem * boton = [[BlockButtonItem alloc] initWithTitle:@&quot;Pulsame&quot; block:^{
    NSLog(@&quot;He sido pulsado!&quot;);
}];
    
self.navigationItem.rightBarButtonItem = boton;
</code></pre>

<h5 id="problemasconlosbloques:">Problemas con los bloques:</h5>

<p>Cuando en el bloque referenciamos un objeto que a la vez (directa o indirectamente) referencia al bloque, da lugar a <em>retain circle</em>. Para ello podemos crear una referencia <code>weak</code> a <code>self</code> con <code>__weak</code>:</p>

<pre><code>- (void)updateUserHomeTown{
    __weak typeof(self) weakSelf=self;
    [self.requestManager homeTownForUser:self.user 
                              completion:^(CityEntity *resultCity){
        weakSelf.homeTownCity=resultCity;
    }];
} 
</code></pre>

<p>Pero cuando en mi bloque se necesita que se ejecute algo, y no se libere self aun cuando su referenciador ya está pidiendo ser liberado, para estos casos críticos la solución es es:</p>

<pre><code>- (void)updateUserHomeTown{
    __weak typeof(self) weakSelf=self;
    [self.requestManager homeTownForUser:self.user 
                              completion:^(CityEntity *resultCity){
        __strong self typeof(weakSelf)=weakSelf;
        self.homeTownCity=resultCity;
    }];
} 
</code></pre>

<h5 id="embelleciendoelcódigo">Embelleciendo el código</h5>

<p>Con la librería <a href="https://github.com/jspahrsummers/libextobjc">libextobjc</a> podemos usar <code>@weakify()</code> y <code>@strongify()</code>:</p>

<p>Sin <code>@weakify</code> <code>@strongify</code>:</p>

<pre><code>- (void)updateUserHomeTown{
    __weak typeof(self) weakSelf=self;
    [self.requestManager homeTownForUser:self.user 
                              completion:^(CityEntity *resultCity){
        __strong self typeof(weakSelf)=weakSelf;
        self.homeTownCity=resultCity;
    }];
} 
</code></pre>

<p>Con <code>@weakify</code> <code>@strongify</code>:</p>

<pre><code>- (void)updateUserHomeTown{
    @weakify(self);
    [self.requestManager homeTownForUser:self.user 
                              completion:^(CityEntity *resultCity){
        @strongify(self);
        self.homeTownCity=resultCity;
    }];
} 
</code></pre>

<h2 id="afnetworking">AFNetworking</h2>

<p><code>AFNetworking</code> es una librería para la gestión de tareas de networking para iOS y OS X que funciona a modo de envoltorio de las librerías del Foundation URL Loading System. Cuando hablamos de Foundation URL Loading System estamos hablando de <code>NSURLConnection</code> y de <code>NSURLSession</code>.</p>

<p>Una buena práctica consiste en crear una clase que te abstraiga del uso de la librería, que nos de cierta libertad para sustituirla en un futuro sin tener que cambiar todas las peticiones a red que se hacen en toda la app.</p>

<p>Para ello creamos una clase que podemos llamar por ejemplo <code>RequestManager</code>.</p>

<p>RequestManager.h</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

typedef void (^RequestManagerSuccess)(id data);
typedef void (^RequestManagerError)(NSError *error);

@interface RequestManager : NSObject

@property (copy,nonatomic) NSString *baseDomain;

- (void)GET:(NSString *)path parameters:(id)parameters successBlock:(RequestManagerSuccess)successBlock errorBlock:(RequestManagerError)errorBlock;

...

(El resto de tipos de peticiones POST, PUT, etc.)

@end
</code></pre>

<p>Y la implementación .m podría ser así:</p>

<pre><code>#import &quot;RequestManager.h&quot;
#import &quot;AFHTTPRequestOperationManager.h&quot;

@implementation RequestManager
- (instancetype)init
{
    self = [super init];
    if (self) {
        _baseDomain=@&quot;http://ironhack4thweek.s3.amazonaws.com&quot;;
    }
    return self;
}
- (void)GET:(NSString *)path parameters:(id)parameters successBlock:(RequestManagerSuccess)successBlock errorBlock:(RequestManagerError)errorBlock{
    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
    [manager GET:[self.baseDomain stringByAppendingPathComponent:path] parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        successBlock(responseObject);
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        errorBlock(error);
    }];
}

@end

</code></pre>

<p>Lo más interesante es que cada modelo/entidad encapsulemos todas sus peticiones de red entro de una clase. Por ejemplo para implementar las peticiones de TVshows hacemos una clase <em>ShowsProvider</em>:</p>

<p>ShowsProvider.h</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import &quot;RequestManager.h&quot;

@interface ShowsProvider : NSObject
- (void)showsWithSuccessBlock:(RequestManagerSuccess)successBlock errorBlock:(RequestManagerError)errorBlock;
@end
</code></pre>

<p>ShowProvider.m</p>

<pre><code>#import &quot;ShowsProvider.h&quot;
#import &quot;TVshow.h&quot;

@interface ShowsProvider()
@property (strong,nonatomic) RequestManager *requestManager;
@end
@implementation ShowsProvider
- (instancetype)init
{
    self = [super init];
    if (self) {
        _requestManager=[[RequestManager alloc] init];
    }
    return self;
}
- (void)showsWithSuccessBlock:(RequestManagerSuccess)successBlock errorBlock:(RequestManagerError)errorBlock{
    
    NSString *path=@&quot;shows.json&quot;;
    NSDictionary *parameters=@{};
    [self.requestManager GET:path parameters:parameters successBlock:^(id data) {
        NSMutableArray *shows=[NSMutableArray array];
        if ([data valueForKey:@&quot;shows&quot;] &amp;&amp; ((NSArray *)[data valueForKey:@&quot;shows&quot;]).count) {
            for (NSDictionary *showDictionary in [data valueForKey:@&quot;shows&quot;]) {
                
                TVshow *show=[[TVshow alloc] init];
                show.id=[showDictionary valueForKey:@&quot;id&quot;];
                show.title=[showDictionary valueForKey:@&quot;title&quot;];
                show.description=[showDictionary valueForKey:@&quot;description&quot;];
                show.posterURL=[NSURL URLWithString:[showDictionary valueForKey:@&quot;posterURL&quot;]];
                [shows addObject:show];
            }
        }
        successBlock(shows);
    } errorBlock:^(NSError *error) {
        errorBlock(error);
    }];
}
@end
</code></pre>

<p>Traerse la lista de series ahora es tan fácil como:</p>

<pre><code>- (void)loadShows{
    
    [self.showsProvider showsWithSuccessBlock:^(id data) {
        self.myshows=data;
        [self.tableView reloadData];
    } errorBlock:^(NSError *error) {
        
    }];
}

</code></pre>

<p>Donde <code>self.myshows</code> es una propiedad del controlador.</p>

<h2 id="concurrencia">Concurrencia</h2>

<p>Grand Central Dispatch (GCD) es una API de bajo nivel para gestionar la concurrencia. Una de sus grandes ventajas es que nos abstrae de la arquitectura del dispositivo. </p>

<p>¿Cómo crear un proceso en otra cola? <strong>dispatch_async</strong></p>

<pre><code>/// Here executes on one queue

dispatch_queue_t dispatch_queue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);

dispatch_async(dispatch_queue, ^{

    /// Here executes on other queue 

});
</code></pre>

<p>Cada hilo se ejecuta una cola al mismo tiempo. Sin embargo una cola puede ejecutar operaciones en diferentes hilos.</p>

<p><strong>main_queue</strong> es un caso especial de cola que se ejecuta siempre en el hilo principal. Todo lo relacionado con la interfaz de usuario (UIKit) se ejecutan sobre este <em>main_queue</em>.</p>

<p>Ejercicio: En el proyecto de las series, en el TableView, descargar las imágenes usando una cola secundaria:</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MyViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;mycell&quot; forIndexPath:indexPath];
    
    cell.loggedUser = self.loggedUser;
    cell.coreDataManager = self.coreDataManager;
    
    TVshow * serie = [self.myshows objectAtIndex:indexPath.row];
    cell.myTitle.text = serie.title;
    cell.myDescription.text = serie.description;

    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        
        NSData *data = [NSData dataWithContentsOfURL: serie.posterURL];
        UIImage *downloaded = [UIImage imageWithData:data];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            cell.myPoster.image = downloaded;
        });
        
    });
    
    return cell;
}

</code></pre>

<p>Nota: La descarga de la imagen se lleva a cabo en el hilo secundario, sin embargo el dibujado se debería hacer en el hilo principal, por tanto lo traemos de vuelta con:</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    cell.myPoster.image = downloaded;
});
</code></pre>

<h5 id="dispatch_once">dispatch_once</h5>

<pre><code>+ (instancetype)sharedInstance{
    static dispatch_once_t onceToken;
    static SingletonClass *instance;
    dispatch_once(&amp;onceToken, ^{
        instance = [[SingletonClass alloc]init];
    });
    return instance;
}
</code></pre>

<p><code>dispatch_once</code> nos permite ejecutar código una sola vez durante la ejecución de la app. Es la manera más usada y recomendada para crear un singlenton.</p>

<h5 id="dispatch_queue_create">dispatch_queue_create</h5>

<pre><code>dispatch_queue_t dispatch_queue = dispatch_queue_create(&quot;com.myawesomeapp.process.processdata&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre>

<p><code>dispatch_queue_create</code> crea una nueva cola que puede ser retenida y reusada.</p>

<p><code>DISPATCH_QUEUE_CONCURRENT</code> nos permite ejecutar multiples operaciones concurrentes y <code>DISPATCH_QUEUE_SERIAL</code> limitaría solo una operación a la vez en la cola.</p>

<hr />

<p>Ejercicio: Crear un serial dispatch_queue para procesar los datos de nuestro provider de series.</p>

<p>Solución: Creamos una propiedad que sería nuestra cola para hacer peticiones de series:</p>

<pre><code>...
@property (strong, nonatomic) dispatch_queue_t serial_dispatch_queue;
...
</code></pre>

<p>En el <em>init</em> del provider, creamos la cola:</p>

<pre><code>- (instancetype)init
{
    self = [super init];
    if (self) {
        _requestManager=[[RequestManager alloc] init];
        _serial_dispatch_queue = dispatch_queue_create(&quot;com.semana4lunes.process.processdata&quot;, DISPATCH_QUEUE_SERIAL);
    }
    return self;
}
</code></pre>

<p>Y cuando vayamos a lanzar la petición asíncrona, lo hacemos pasándola nuestra cola:</p>

<pre><code>...
dispatch_async(self.serial_dispatch_queue, ^{ 
    ...
});
...
</code></pre>

<hr />

<p>Ejercicio: Aunque tenemos una categoría de UIImageView para &#8220;setear&#8221; la imagen dada una URL, ahora tenemos que crear un singleton llamado <em>ImageDownloader</em> que se encarga de descargar las imágenes en su propio hilo:</p>

<p>Solución: Primero creamos el singleton, en el <em>.h</em>:</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface ImageDownloader : NSObject

+ (instancetype)sharedInstance;
- (void)downloadImageWithURL:(NSURL *)imageURL completion:(void (^)(UIImage * image))completion;

@end
</code></pre>

<p>La implementación del <em>.m</em>:</p>

<pre><code>#import &quot;ImageDownloader.h&quot;

@interface ImageDownloader ()
@property (strong, nonatomic) dispatch_queue_t downloadQueue;
@end

@implementation ImageDownloader

+ (instancetype)sharedInstance
{
    static dispatch_once_t onceToken;
    static ImageDownloader *instance;
    dispatch_once(&amp;onceToken, ^{
        instance = [[ImageDownloader alloc] init];
    });
    return instance;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        _downloadQueue = dispatch_queue_create(&quot;com.miapp.process.download&quot;, DISPATCH_QUEUE_CONCURRENT);
    }
    return self;
}

- (void)downloadImageWithURL:(NSURL *)imageURL completion:(void (^)(UIImage * image))completion{
    
    dispatch_async(self.downloadQueue, ^{
        
        NSData *data = [NSData dataWithContentsOfURL: imageURL];
        UIImage *downloaded = [UIImage imageWithData:data];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(downloaded);
        });
        
    });
}


@end

</code></pre>

<p>Por último, en nuestra categoría, hacemos uso de esta clase:</p>

<pre><code>#import &quot;UIImageView+vitaminada.h&quot;
#import &quot;ImageDownloader.h&quot;

@implementation UIImageView (vitaminada)

- (void)setImageWithURL:(NSURL *)imageURL completion:(void (^)(BOOL success))completion{
    
    [[ImageDownloader sharedInstance] downloadImageWithURL:imageURL completion:^(UIImage *image) {
        self.image = image;
        completion(YES);
    }];
}

@end
</code></pre>

<h5 id="caché:">Caché:</h5>

<p>Como estamos reusando las celdas, cada vez que se muestran se desencadena la descarga de la imagen. Pasos:</p>

<ul>
<li>Creamos un singleton que podemos llamar <em>CacheManager</em> con dos métodos públicos que nos permite guardar una imagen en disco registrándola en un plist y leer la imagen para evitar descargarla de nuevo. Este sería el <em>.m</em>:</li>
</ul>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface CacheManager : NSObject

+ (instancetype)sharedInstance;
- (void) getCachedImageWithURL: (NSURL *) url completion:(void (^)(UIImage * image))completion;
- (void) saveInCache: (NSData *) image withFilename:(NSString *) filename fromURL: (NSURL *) url completion:(void (^)(BOOL completion))completion;

@end
</code></pre>

<ul>
<li>Esta sería una posible implementación de estos dos metodos:</li>
</ul>

<pre><code>- (void) getCachedImageWithURL: (NSURL *) url completion:(void (^)(UIImage * image))completion{
    NSString * path = [self itemInPlistWithURL:url];
    
    if(!path){
        completion(nil);
    }
    
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *filePath = [documentsPath stringByAppendingPathComponent: path];
    UIImage * image = [UIImage imageWithData:[NSData dataWithContentsOfFile:filePath]];
    completion(image);
}

- (void) saveInCache: (NSData *) image withFilename:(NSString *) filename fromURL: (NSURL *) url completion:(void (^)(BOOL completion))completion{
 
    NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *filePath = [documentsPath stringByAppendingPathComponent:filename];
    [image writeToFile:filePath atomically:YES];
    
    [self insertItemInPlist:filename fromURL:url];
    completion(YES);
}
</code></pre>

<ul>
<li>Los métodos privados auxiliares son:</li>
</ul>

<pre><code>#pragma mark - private methods

- (NSString *) itemInPlistWithURL: (NSURL *) url{
    NSDictionary * items = [self itemsInPlist];
    NSString * filename = [items objectForKey:[url description]];
    return filename;
}


- (NSDictionary *) itemsInPlist {
    return [NSDictionary dictionaryWithContentsOfFile:self.filePath];
}


- (void) insertItemInPlist: (NSString *) filename fromURL: (NSURL *) url {
    NSMutableDictionary * dictionary = [NSMutableDictionary dictionaryWithDictionary:[self itemsInPlist]];
    [dictionary setObject:filename forKey:[url description]];
    [dictionary writeToFile:self.filePath atomically:YES];
}
</code></pre>

<ul>
<li>En nuestro singleton para descargar las imágenes, deberíamos comprobar primero si la imagen está cacheada y en el caso de que no, se descarga y enviarle a nuestro &#8220;CacheManager&#8221; los datos necesarios para que la cachee.</li>
</ul>

<h2 id="locks">Locks</h2>

<p>A veces, que varios hilos tengan acceso a los mismos recursos puede provocar comportamientos inesperados o bugs difíciles de depurar. Por ello podemos usar <strong><em>locks</em></strong> para proteger secciones importantes de nuestra app y sincronizar el acceso a ellas. El uso de estos requiere precaución porque si se hace incorrectamente genera problemas de otro nivel.</p>

<p>Los <strong><em>Deadlocks</em></strong> representan situaciones en las que un hilo está esperando que se libere un recurso del otro hilo, y a la vez tiene bloqueado un proceso, en que el segundo hilo está a la espera. </p>

<pre><code>dispatch_queue_t myDispatchQueue;
dispatch_async(myDispatchQueue, ^{
    /// Some code
    dispatch_sync(myDispatchQueue,^{
        /// This never reaches
    });
});
</code></pre>

<p>Clásico error de novato: <code>dispatch_sync</code> bloquea la cola inmediatamente hasta el final del bloque, por tanto la siguiente invocación a <code>dispatch_sync</code> mantendrá el hilo a la espera a que se libere y esto no pasará hasta continue la ejecución, o sea: deadlock.</p>

<p>Cada vez que intentamos bloquear dos recursos a la vez, es una posible fuente de deadlocks, un <em>code smell</em> de libro.</p>

<p>Los <strong><em>livelocks</em></strong> son parecidos a los deadlocks pero sin que haya hilos bloqueados de por medio, por ejemplo con ficheros en disco. Se entiendo mejor con la metáfora de los dos hombres muy educados en el que uno le cede el paso al otro por educación y el segundo hace lo mismo. </p>

<p>La mejor manera de lidiar con livelocks y deadlocks es evitando bloquear dos recursos a la vez.</p>

<h5 id="syncronize">@syncronize</h5>

<p>Esta directiva nos permite sincronizar fácilmente el acceso a secciones críticas de nuestra app.</p>

<pre><code>
- (void)myMethod:(id)anObj
{
    @synchronized(anObj)
    {
        // Everything between the braces is protected 
        // by the @synchronized directive.
    }
}

</code></pre>

<p>Es común pasarle <code>self</code> a la directiva para sincronizar varias secciones o una variable estáticas de tipo <code>string</code>, para asegurarse de que cuando se invoque exista y no apunte a <code>nil</code>.</p>

<p>En nuestro ejemplo anterior en el que creábamos un singleton para gestionar la caché, podríamos bloquear la lectura y escritura de las imágenes y del plist.</p>

<pre><code>...
@synchronized(self){
    image = [UIImage imageWithData:[NSData dataWithContentsOfFile:filePath]];
}
...
@synchronized(self){
    [image writeToFile:filePath atomically:YES];
}
...
@synchronized(self){
    plisData = [NSDictionary dictionaryWithContentsOfFile:self.filePath];
}
...
@synchronized(self){
    [dictionary writeToFile:self.filePath atomically:YES];
}
...
}
</code></pre>

<p>Nota: el uso de @synchronized exige el uso del Exception Handle.</p>

<h5 id="nslock">NSLock</h5>

<p>Otra forma de bloquear secciones para garantizar la sincronización.</p>

<pre><code>@property(strong,nonatomic) NSLock *criticalResourceLock;

- (NSLock *)criticalResourceLock{
    if(!_criticalResourceLock){
        _criticalResourceLock=[[NSLock alloc] init];
    }
    return _criticalResourceLock;
}
</code></pre>

<pre><code>BOOL moreToDo = YES;
NSLock *theLock = [self criticalResourceLock];
...
while (moreToDo) {
    /* Do another increment of calculation */
    /* until there’s no more to do. */
    if ([theLock tryLock]) {
        /* Update display used by all threads. */
        [theLock unlock];
    }
}
</code></pre>

<p><code>NSLock</code> siempre libera el bloqueo en el mismo hilo en el que se bloqueó.</p>

<p>Para nuestro ejemplo, podríamos hacer algo así:</p>

<pre><code>...
@property (strong,nonatomic) NSLock *criticalResourceLock;
...
- (NSLock *)criticalResourceLock{
    if(!_criticalResourceLock){
        _criticalResourceLock=[[NSLock alloc] init];
    }
    return _criticalResourceLock;
}
...
while (![self.criticalResourceLock tryLock]) {}
UIImage * image = [UIImage imageWithData:[NSData dataWithContentsOfFile:filePath]];
[self.criticalResourceLock unlock];
...
</code></pre>

				  
				  
				  <!-- %%%%%% -->
			  </div>
			  
			  
			  
			  <!-- 
			  <div class="bs-docs-section" id="w00-section">
				  <h1 id="w00" class="page-header">Semana 00</h1>
				  
				  <!-- &&&&&& ->
				  
				  <!-- %%%%%% ->
			  </div>
			  -->

        </div>
        
      </div>

    </div>

    <!-- Footer
================================================== -->
<footer class="bs-docs-footer" role="contentinfo">
  <div class="container">
    <p>Built with all the love in the world by <a href="https://github.com/rafaparadela" target="_blank">Rafa Paradela</a>.</p>
    <p>Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="assets/jquery.min.js"></script>
<script src="assets/bootstrap.min.js"></script>
<script src="assets/docs.min.js"></script>
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!--Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52390861-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>
