
<!DOCTYPE html>
<html lang="en">
  <head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="IronHack MADRID - iOS Development">
<meta name="keywords" content="Objective-c, Cocoa, Xcode, Ironhack, Development">
<meta name="author" content="Rafa Paradela">
<title>IronHack - iOS Development</title>
<link href="assets/bootstrap.min.css" rel="stylesheet">
<link href="assets/docs.min.css" rel="stylesheet">

<link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
<link href="assets/theme.css" rel="stylesheet">

<!--[if lt IE 9]><script src="../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->
  </head>
  <body>
    <a class="sr-only" href="#content">Skip to main content</a>

    <!-- Docs master nav -->
  <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="../" class="navbar-brand">IronHack - iOS Development</a>
    </div>
	<!--
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        <li>
          <a href="../getting-started">Getting started</a>
        </li>
        <li>
          <a href="../css">CSS</a>
        </li>
        <li>
          <a href="../components">Components</a>
        </li>
        <li>
          <a href="../javascript">JavaScript</a>
        </li>
        <li class="active">
          <a href="../customize">Customize</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="http://expo.getbootstrap.com" onclick="_gaq.push(['_trackEvent', 'Navbar', 'Community links', 'Expo']);">Expo</a></li>
        <li><a href="http://blog.getbootstrap.com" onclick="_gaq.push(['_trackEvent', 'Navbar', 'Community links', 'Blog']);">Blog</a></li>
      </ul>
    </nav>
	-->
  </div>
</header>

    <div class="container bs-docs-container">

      <div class="row">
		  
		  
        <div class="col-md-2">
          <div class="bs-docs-sidebar hidden-print" role="complementary">
            <ul class="nav bs-docs-sidenav">
              
				<li><a href="#w01">Semana 1</a></li>
				<li><a href="#w02">Semana 2</a></li>
				<li><a href="#w03">Semana 3</a></li>
              
            </ul>
            <a class="back-to-top" href="#top">
              Back to top
            </a>
          </div>
        </div>
		
        <div class="col-md-10" role="main">
          <!-- Customizer form -->

			  <div class="bs-docs-section" id="w01-section">
				  <h1 id="w01" class="page-header">Semana 1</h1>
				  
				  <!-- &&&&&& -->

<h3>Xcode</h3>

<p>Xcode no es solo un IDE m√°s, es una herramienta compleja.</p>

<p>Para ilustrar el repaso por los conceptos m√°s b√°sicos de Xcode, hacemos un <em>Hello World</em> en el que simplemente imprimimos <code>Hello World</code> en la consola. Para no convertir este art√≠culo en un tutorial de Xcode 5, pongo un enlace hacia un <a href="http://codewithchris.com/xcode-tutorial/">Tutorial de Xcode</a>, un tutorial de <a href="http://codewithchris.com/first-xcode-project/">C√≥mo crear el primer proyecto en Xcode</a> y listo algunas anotaciones que me parecen interensantes:</p>

<ul>
<li>Cuando se crea un proyecto en Xcode, te da la posibilidad de especificar un <code>Class Prefix</code>. Digamos que esto sustituye el sistema de paquetes de otros lenguajes y entornos, y sirve para evitar que existan clases con el mismo nombre. Algunos ejemplos de prefijos de clase archiconocidos pueden ser NS, UI y CF.</li>
<li>Un proyecto Xcode escrito en Objective-c no deja de ser un programa en C supervitaminado. Por tanto el punto de entrada es la funci√≥n <code>main</code>, que Xcode coloca <em>MyProject >> Supporting FIles >> main.m</em>. El contenido por defecto de esta funci√≥n en este tipo de proyectos es la llamada a UIApplicationMain (para iniciar el ciclo de eventos de la aplicaci√≥n). Lo encapsula en un bloque <code>@autoreleasepool</code> que b√°sicamente sirve para liberar la memoria tras la ejecuci√≥n.</li>
<li>El delegado de la aplicaci√≥n es una clase que podemos considerar como la puerta para que la aplicaci√≥n se comunique con el dispositivo. Entre sus m√©todos, el m√°s importante es <code>didFinishLaunchingWithOptions</code> que avisa cuando la aplicaci√≥n se abre.</li>
<li>En Xcode el uso de los <em>Targets</em> es un sistema para organizar el proceso de compilaci√≥n del proyecto. Se pueden a√±adir pasos a los que por defecto se llevan a cabo cuando se construye la app, que se <em>precompila -> compila -> enlaza -> empaqueta</em>.</li>
<li>El uso de esquemas, tambi√©n es √∫til para manipular la ejecuci√≥n. Por ejemplo es donde habr√≠a que definir los argumentos de entrada.</li>
</ul>


<h3>Un vistazo r√°pido a C</h3>

<p>Es importante recordar algunos conceptos del "abuelo" C, para ello os recomiendo echar vistazo a alg√∫n tutorial, por ejemplo <a href="http://www.cprogramming.com/tutorial/c-tutorial.html">este</a>. Nosotros creamos un proyecto de C en Xcode y jugamos un poco con los tipos de variables, la declaraci√≥n y definici√≥n de funciones, con los argumentos de entrada, etc. Algunas anotaciones que merece la pena recordar:</p>

<ul>
<li>Podemos definir nuestros propios tipos de variables con typedef, ejemplo: <code>typedef unsigned int NSUinteger;</code></li>
<li>Con <code>sizeof</code> podemos saber el tama√±o que ocupa un tipo en memoria.</li>
<li>Los archivos <em>.h</em> no se meten en el target porque no se compilan.</li>
<li>Es importante recordar la visibilidad de las funciones. Si declaras una funci√≥n en el <em>.h</em>, se podr√°n invocar dichas funciones importando la cabecera, sin embargo, si se declara y define una funci√≥n en el <em>.c</em> se considera una funci√≥n privada, √∫til en el √°mbito del m√≥dulo.</li>
<li>Es posible declarar una variable en el ambito del m√≥dulo pero solo visible en la funci√≥n donde se define. En el siguiente ejemplo <code>sequence</code> se incrementar√° en cada llamada, <code>next_in_sequence()</code> puede ser una funci√≥n publica pero quien la llame no pude modificar el valor de <code>sequence</code>:</li>
</ul>


<pre><code>NSUinteger next_in_sequence(){
    static NSUinteger sequence = 0;
    sequence ++;
    return sequence;
}
</code></pre>

<h3>Primera toma de contacto con Objective-c</h3>

<p>Para ir meti√©ndonos en "manteca", creamos un nuevo proyecto llamado <a href="https://github.com/rafaparadela/iron-hack-week1-beer"><em>Beers</em></a> y que nos servir√° durante toda la semana como proyecto de pruebas.</p>

<p>Creamos una clase llamada <em>Beer</em> que nos servir√° de ejemplo para ilustrar como se definen las variables de la clase, de la instancia, los m√©todo privados, p√∫blicos, etc.</p>

<p>En <em>Beer.h</em> (interfaz de la clase) vemos que es una clase que extiende a NSObject <code>@interface Beer : NSObject</code>, y por tanto hereda ciertos m√©todos propios de cualquier objeto. Vamos a declarar varias variables de instancia, por tanto en la interfaz:</p>

<pre><code>@private
    NSString *name;
    NSString *color;
    NSUInteger grade;
}
</code></pre>

<p>Una variable <em>name</em> de tipo <code>NSString</code> que representar√° el nombre de la cerveza, una variable <em>color</em> de tipo <code>NSString</code> que representar√° el color de la cerveza y una variable <em>grade</em> del tipo <code>NSUInteger</code> que representar√° la graduaci√≥n de alcohol. Los asteriscos de <em>name</em> y <em>color</em> denotan que realmente dichas variables son punteros, que guardar√°n la direcci√≥n de memoria (<em>heap</em>) donde se almacenar√° el contenido del objeto <code>NSString</code>. Sin embargo <em>grade</em>, al ser un <code>NSUInteger</code> o sea un entero sin signo no es m√°s que un tipo primario que puede ser guardado localmente (<em>stack</em>).</p>

<h5>Setter &amp; Getter</h5>

<p>Es poco recomendable leer y escribir las variables de instancias accediendo directamente con el operador <code>-&gt;</code> de esta forma <code>cerveza-&gt;name = @"Mahou";</code>. Es m√°s com√∫n implementar los m√©todos que leer√°n y escribir√°n estas variables, los getter y los setters. De esta manera tendremos varias vantajas como mayor control en la inicializaci√≥n poniendo condiciones por ejemplo, no se reserva memoria hasta que se llame al m√©todo, omitir el setter impidiendo que sea escrita desde fuera, etc.</p>

<p>Por convenio el getter se nombran igual que la variable que devuelve y los setters se nombran igual que la variable pero con el prefijo <em>set</em>.</p>

<pre><code>- (NSString *) name;
- (void) setName: (NSString * )newName;

- (NSString *) color;
- (void) setColor: (NSString * )newColor;

- (NSUInteger) grade;
- (void) setGrade: (NSUInteger)newGrade;
</code></pre>

<p>En Beer.m la implemetaci√≥n de estos m√©todos ser√≠a algo as√≠:</p>

<pre><code>- (NSString *) name{
    return self-&gt;name;
}

- (void) setName: (NSString * )newName{
    self-&gt;name = newName;
}
</code></pre>

<p>Existe una notaci√≥n que nos permite invocar a los m√©todos usando el punto
<code>[mahou setName:@"Mahou"];</code> es exactamente igual que <code>mahou.name = @"Mahou";</code>, esta notaci√≥n punto solo es v√°lida si cumples la convenci√≥n de nombrar el getter con el nombre de la variable y el setter como setNombre de la variable de instancia.</p>

<p>La variable self es un puntero al propio objeto, pero hay convenio para nombrar las variables privadas de instancias, con el prefijo <code>_</code> para evitar confusi√≥n:</p>

<pre><code>- (void) setCountry: (NSString * )newCountry{
    _country = newCountry;
}
</code></pre>

<p>Con <code>@property</code> definimos una variable de instancia y el compilador le a√±ade setter y getter:</p>

<pre><code>@property (nonatomic, strong) NSString *country;
</code></pre>

<p>Debes especificar con <code>@synthesize country = _country;</code> si quieres programar tu propio setter y getter. Cuando se establece una propiedad booleana como <code>@property (nonatomic) BOOL married;</code> podemos renombrar el nombre del getter <code>@property (nonatomic, getter = isMarried) BOOL married;</code>.</p>

<h5>M√©todos inicializadores</h5>

<p>Para ilustrar la inicializaci√≥n de los objetos vamos a crear una nueva clase llamada <em>Person</em>.</p>

<p>En la intefaz creamos por ejemplo estas propiedades:</p>

<pre><code>@property (nonatomic, strong) NSString *name;
@property (nonatomic) NSUInteger age;
@property (nonatomic, strong) NSString *address;
@property (nonatomic, getter = isMarried) BOOL married;
</code></pre>

<p>Podemos declarar tantos m√©todos inicializadores que queramos pero todos deben empezar por init. Normalmente se suelen anidar de manera que un m√©todo inicializador puede llamar a otro m√°s descriptivo pas√°ndole valores por defecto. Aquel que recibe m√°s par√°metros y por tanto describe mejor al objeto que iniciliza se denomina <em>designated initializer</em>. Un ejemplo:</p>

<pre><code>- (id) init;
- (id) initWithName: (NSString *)name;
- (id) initWithName: (NSString *)name andAddress: (NSString *)address;
- (id) initWithName: (NSString *)name andAddress: (NSString *)address age: (NSUInteger) age;
</code></pre>

<p>La implementaci√≥n de estos inicializadores podr√≠a ser as√≠:</p>

<pre><code>- (id) initWithName: (NSString *)name andAddress: (NSString *)address age: (NSUInteger) age{
    self = [super init];
    if(self){
        _name = name;
        _address = address;
        _age = age;
    }
    return self;
}
</code></pre>

<table>
<thead>
<tr>
<th> Nota </th>
</tr>
</thead>
<tbody>
<tr>
<td> <em>En los m√©todos inicializadores no se usan las propiedades, son los √∫nico m√©todos que deben usar las variables de instancia</em> </td>
</tr>
</tbody>
</table>


<p>Los siguientes m√©todos podr√≠an implementarse as√≠:</p>

<pre><code>- (id) initWithName: (NSString *)name andAddress: (NSString *)address{
    self = [self initWithName:name andAddress:address age:99];
    return self;
}

- (id) initWithName: (NSString *)name{
    self = [self initWithName:name andAddress:@"Sin definir"];
    return self;
}

- (id) init{
    self = [self initWithName:@"Anonimo"];
    return self;
}
</code></pre>

<h5>M√©todos de clase</h5>

<p>A veces es interesante crear un m√©todo que solo sirva para inicializar un objeto con los par√°metros ya predefinidos. Para eso se usan los m√©todos de clase, que se caracterizan porque sirven para inizializar objetos, no pueden acceder a las variables de instancia y en la interfaz/implementaci√≥ns viene precedidos por un signo m√°s. √âsta podr√≠a ser un m√©todo de clase de Person:</p>

<pre><code>+ (id) personWithName: (NSString *)name{
    return [[Person alloc] initWithName:name];
}
</code></pre>

<p>Y as√≠ se podr√≠a crear una persona <code>Person *homer = [Person personWithName:@"Homer Simpson"];</code></p>

<h3>Primeros test de unidad</h3>

<p>En los proyectos de Xcode, por defecto se crea un directorio donde crear la clases de testeo. Por lo general son clases que extienden a <em>XCTestCase</em>, y en la implementaci√≥n estar√°n los m√©todos que prueban el comportamiento de las clases. √âste ser√≠a un ejemplo de test:</p>

<pre><code>#define TEST_ERROR_MSG @"OMG! üíÄ"
...
- (void)testCanCreateABeerList {
    BeerList *allBeers = [[BeerList alloc] init];
    XCTAssertNotNil(allBeers, TEST_ERROR_MSG);
    XCTAssertEqual(0, [allBeers count], @"Expected %d but found %lu!", 0, [allBeers count]);
}
</code></pre>

<h6>Nota</h6>

<p>Desarrollo guiado por pruebas <code>TDD</code> es una t√©cnica de programaci√≥n que consiste en implementar primero los test unitarios e ir a√±adiendo el c√≥digo necesario m√≠nimo hasta pasar la prueba con √©xito.</p>

<h6>Nota</h6>

<p>As√≠ se puede iterar un array usando bloques:</p>

<pre><code>[[allBeers allBeers] enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Beer *beerToTest = (Beer *)obj;
    NSLog(@"%lu",(unsigned long)idx);
}];
</code></pre>

<h3>KVC: Key Value Coding</h3>

<p>KVC es un mecanismo que nos da la posibilidad de obtener y definir propiedades de una clase especificando identificadores (key) que representan los nombres de los atributos a los que queremos acceder.</p>

<p><code>[allBeers valueForKey:@"count"]</code> es igual que <code>allBeers.count</code></p>

<h3>Leer archivo plist</h3>

<p>Despues de crear y rellenar un archivo plis con esta estructura:</p>

<p>Desde la lista de cevezas podemos leerlo, y a√±adirlo como cerveza:</p>

<pre><code>NSString *fileNameAndPath = [[NSBundle mainBundle]pathForResource:fileName ofType:@"plist"];
NSArray *array = [NSArray arrayWithContentsOfFile:fileNameAndPath];

for (NSDictionary *dict in array) {
   Beer *beer = [[Beer alloc] init];
   beer.name = [dict objectForKey:@"name"];
   beer.grade = [[dict objectForKey:@"grade"] integerValue];
   beer.color = [dict objectForKey:@"color"];
   beer.country = [dict objectForKey:@"country"];

   []self addBeer:beer];
}
</code></pre>

<h3>MRC (Manual Reference Counting) y ARC (Automatic Reference Counting)</h3>

<p>Hasta el iOS 5, el desarrollador ten√≠a que mantener manualmente el seguimiento de la cantidad de referencias correspondientes a cada uno de los objetos creado (MRC), liber√°ndolo correctamente despu√©s de que el objeto ya no fuese necesario para nadie m√°s. De modo que, por ejemplo, antes de iOS 5, era preciso escribir algo como esto:</p>

<pre><code>NSArray *anArray = [[NSArray alloc] initWithObjects:@"one", @"two", nil];
self.myArrayProperty = anArray;
[anArray release];
</code></pre>

<p>A partir de iOS 5, el compilador a√±ade autom√°ticamente el c√≥digo necesario para gestionar la memoria. Pero es preciso conocer el mecanismo por si nos tenemos que enfrentar con c√≥digo pre-iOS 5.</p>

<p>¬øCu√°ndo tengo que liberar memoria? Cuando a√±ado un <code>alloc</code>, <code>new</code> o <code>copy</code> hay liberar con <code>release</code>.</p>

<p>¬øCu√°ndo tengo que hacer <code>-retainCount</code>? <a href="http://whentouseretaincount.com/">Aqu√≠ la respuesta</a>.</p>

<hr />

<p><em><strong>Nota r√°pida:</strong> Solo se debe usar <code>weak</code> en los delegados y outlet.</em></p>

<hr />

<h3>Ejercicio final de semana:</h3>

<p>Para acabar la semana, afianzamos los conceptos con un ejercicio: <a href="http://cl.ly/VvPD">Enunciado</a>.</p>

<p>Est√° resuelto en este repositorio: <a href="https://github.com/rafaparadela/Ironhack-week-1-iOS-exercises---Bars-app">Resoluci√≥n</a></p>

<h3>Algunas anotaciones extras</h3>

<p><strong><a href="http://alcatraz.io/">Alcatraz</a></strong> The package manager for Xcode:</p>

<p><strong><a href="https://github.com/venmo/synx">Synx</a></strong> A command-line tool that reorganizes your Xcode project folder to match your Xcode groups</p>

<p><strong><a href="http://simpholders.com/">SimPholders</a></strong> A small utility for fast access to your iPhone Simulator apps.</p>

<p><strong><a href="https://popapp.in/">POP</a></strong> Prototyping on Paper | iPhone App Prototyping Made Easy.</p>

<p><strong><a href="http://cocoapods.org/">CocoaPods</a></strong> The Dependency Manager for Objective C.</p>

<ul>
<li>Editas Podfile con las dependencias</li>
<li>pod install instala las dependencias</li>
<li>Y desde ese momento, se debe abrir el workspace y no el xcodeproject.</li>
</ul>


<h4>Categorias:</h4>

<ul>
<li>Se crea una categoria sobre "algo".</li>
<li>Si escribes un m√©todo que ya existe, la sobreescribe.</li>
<li>Lo importamos en el pch de sipporting files para tenerlo en todos.</li>
<li>Las categorias en principio no soportaban propiedades, es mas facil definir una variable de instancia.</li>
</ul>


				  <!-- %%%%%% -->
				  
			  </div>

			  <div class="bs-docs-section" id="w02-section">
				  <h1 id="w02" class="page-header">Semana 2</h1>

				  <!-- &&&&&& -->
				  


<p>Empezamos planificando la semana y present√°ndonos a un nuevo profesor: <a href="https://twitter.com/frsevillano">Fran Sevillano</a>.</p>

<h3>MVC</h3>

<p>El patr√≥n Model-View-Controller consiste en dividir el c√≥digo en 3 capas diferenciadas, donde los modelos representan los datos que se van a manejar, las vistas representan los elementos que conforman la interfaz de usuario y los controladores, que responden a los eventos para interactuar con las vistas y con los modelos. Las vistas en Objective-c no tiene acceso a los modelos directamente sino que se comunica con los controladores que les proveer√° de la informaci√≥n necesaria. Esta cominicaci√≥n "fluye" por varias v√≠as.</p>

<p><img src="http://res.cloudinary.com/rafaparadela/image/upload/v1402386815/Captura_de_pantalla_2014-06-09_a_la_s_19_23_21_rqrgvx.png" alt="image" /></p>

<h5>Target-Action</h5>

<p>Esta t√©cnica consiste en enviar un mensaje cuando un evento ocurre. El objeto <code>target</code> recibir√° un mensaje, <code>action</code> cuando ocurra el evento <code>controlEvents</code></p>

<pre><code>(void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents
</code></pre>

<p>Hay muchos objetos en el SDK al los que se les puede enviar mensajes en respuesta a un evento. Como por ejemplo: UIButton, UILabel, UISwitch, UISlider, UISegmentedControl, UIPageControl, UIStepper, etc.</p>

<p>As√≠ podemos a√±adir un bot√≥n a la vista, y asignarle un t√≠tulo.</p>

<pre><code>UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];
button.frame = CGRectMake(10, 10, 100, 50);
[self.view addSubview:button];
[button setTitle:@"Normal" forState:UIControlStateNormal];
[button setTitle:@"Resaltado" forState:UIControlStateHighlighted];
</code></pre>

<p>Si queremos mandarle un mensaje cuando sea pulsado, y desencadene la ejecuci√≥n del m√©todo <code>buttonPressed</code>:</p>

<pre><code>[button addTarget:self action:@selector(buttonPressed) forControlEvents:UIControlEventTouchDown];
</code></pre>

<p>El manejo de los labels es similar. As√≠ a√±adimos un label, con el texto <em>Hola</em>, con la tipograd√≠a <em>Georgia</em> de tama√±o 20 puntos en color verde:</p>

<pre><code>UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(300, 10, 300, 50)];
[self.view addSubview:label];
[label setText:@"Hola"];
[label setFont:[UIFont fontWithName:@"Georgia" size:20]];
[label setTextColor:[UIColor greenColor]];
</code></pre>

<p>Un ejercicio sencillo, dadas las propiedades <code>UILabel * mylabel</code> y <code>UISwitch * myswitch</code> ¬øC√≥mo cambiar la manera en la que el sistema truca el texto del label, dependiendo de si un switch est√° activado o desactivado?</p>

<pre><code>@property (nonatomic, strong) UILabel * mylabel;
@property (nonatomic, strong) UISwitch * myswitch;

...

- (void)exercise
{

    self.myswitch = [[UISwitch alloc] initWithFrame:CGRectMake(10, 140, 300, 50)];
    [self.view addSubview:self.myswitch];
    [self.myswitch addTarget:self action:@selector(setLineBreakMode) forControlEvents:UIControlEventValueChanged];

    self.mylabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 190, 120, 50)];
    [self.view addSubview:self.mylabel];
    [self.mylabel setText:@"Lorem ipsum dolor sit amet"];
    [self.mylabel setBackgroundColor:[UIColor greenColor]];

}

- (void)setLineBreakMode
{
    if ([self.myswitch isOn]) {
        [self.mylabel setLineBreakMode:NSLineBreakByTruncatingHead];
    }else{
        [self.mylabel setLineBreakMode:NSLineBreakByTruncatingTail];
    }

}
</code></pre>

<p>Y un sencillo ejemplo de c√≥mo crear un UISegmentedControl, con las opciones <em>Hola</em> y <em>Adi√≥s</em> y que mande el mensaje <code>setLineBreakMode</code> cuando cambie su valor:</p>

<pre><code>UISegmentedControl * mysegmented = [[UISegmentedControl alloc] initWithItems:@[@"Hola",@"Adios"]];
[mysegmented setFrame:CGRectMake(10, 390, 200, 50)];
[self.view addSubview:mysegmented];
[mysegmented addTarget:self action:@selector(setLineBreakMode) forControlEvents:UIControlEventValueChanged];
</code></pre>

<h3>Delegation</h3>

<p>Consiste en delegar parte de la funcionalidad de un objeto a otro, habilitando por ejemplo la posibilidad de personalizar multiples vistas desde un solo controlador.</p>

<p>Para establecer la relaci√≥n de delegaci√≥n se debe llevar a cabo los siguientes pasos:</p>

<ul>
<li>La clase delegada debe definir un protocolo (con el mismo nombre del controlador y el sufijo <em>Delegate</em>), que consiste en declarar una serie de m√©todos.</li>
</ul>


<pre><code>@protocol MyViewControllerDelegate &lt;NSObject&gt;
- (void) oneMethod;
@end
</code></pre>

<ul>
<li>La clase delegada debe tener una propiedad (<em>weak</em>) llamada <code>delegate</code>, del tipo gen√©rico <code>id</code> con la restricci√≥n de que extienda el protocolo:</li>
</ul>


<pre><code>@property (nonatomic, weak) id&lt;MyViewControllerDelegate&gt; delegate;
</code></pre>

<ul>
<li>Que el m√©todo delegador extienda el protocolo:</li>
</ul>


<pre><code>@interface OtherViewController ()&lt;MyViewControllerDelegate&gt;
</code></pre>

<ul>
<li>Que el m√©todo delegador implemente los m√©todos del protocolo:</li>
</ul>


<pre><code>- (void) oneMethod{
    NSLog(@"Pollito");
}
</code></pre>

<ul>
<li>Para establecer que un objeto de <code>OtherViewController</code> sea el delegador de un objeto <code>MyViewController</code>, ser√≠a algo as√≠ (si se hace desde <code>OtherViewController</code>):</li>
</ul>


<pre><code>self.anyViewController = [[MyViewController alloc] init];
self.anyViewController.delegate = self;
</code></pre>

<ul>
<li>Ahora desde <code>MyViewController</code> podemos delegar algunas funcionalidades sobre <code>OtherViewController</code>, en este caso delegar el m√©todo <code>oneMethod</code>:</li>
</ul>


<pre><code>[self.delegate oneMethod];
</code></pre>

<p>Normalmente se usa la t√©cnica <em>delegate</em> para definir la funcionalidad de un conjunto de controles como: UITextField y su protocolo UITextFieldDelegate con el que podemos personalizar su comportamiento, UITextView y UITextViewDelegate, UIAlertView, UIActionSheet, etc.</p>

<h3>Notificaciones</h3>

<p>Las notificaciones se usan para comunicar los modelos con los controladores. Consiste en enviar un mensaje de difusi√≥n, con cierta informaci√≥n, que es escuchada por aquellos objetos que se subscriban. Es la clase <code>NSNotificationCenter</code> la encargada de este flujo.</p>

<p>El env√≠o y lectura de notificaciones se entiende mucho mejor con un ejemplo. Imaginemos dos vistas diferentes independeientes, gestionadas mediante dos ViewControllers. En la primera de las vistas tenemos un UITextField y la segunda un UILabel. El prop√≥sito es que cuando se cambie campo de texto de la primera vista, se escriba en el label de la segunda vista exactamente el mismo texto:</p>

<pre><code>@property (nonatomic, strong) UITextField *textField;

...

- (void)exercise
{
    self.textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 40, 300, 40)];
    [self.view addSubview:self.textField];    
    [self.textField addTarget:self action:@selector(changedField) forControlEvents:UIControlEventEditingChanged];


} 

- (void)changedField{
    [[NSNotificationCenter defaultCenter] postNotificationName:@"myTextNotification" object:self userInfo:@{@"mytexto" : self.textField.text}];
}
</code></pre>

<p>As√≠ estar√≠amos enviando una notificaci√≥n llamada <em>myTextNotification</em> con los datos serializados en un diccionario llamado <em>userInfo</em>, en este caso el nuevo texto como valor cuya clave es <em>@"mytexto"</em>. Los recibir√≠a todo aquel que se suscriba a dicha notificaci√≥n. En este caso desde la segunda vista:</p>

<pre><code>@property (nonatomic, strong) UILabel * mylabel;

...

- (void)exercise
{
    self.mylabel = [[UILabel alloc] initWithFrame:CGRectMake(10, 90, 300, 40)];
    [self.view addSubview:self.mylabel];

    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(receiveNotification:) name:@"myTextNotification" object:nil];

}

- (void)receiveNotification:(NSNotification *)notification
{
    NSDictionary *userInfo = notification.userInfo;
    self.mylabel.text = [userInfo objectForKey:@"texto"];
}
</code></pre>

<p>De esta manera recibir√≠a la notificaci√≥n <em>myTextNotification</em> y se la enviar√≠a al m√©todo <em>receivenotification</em> que actualiza el texto del label.</p>

<h2>Martes 10</h2>

<h3>View Controllers</h3>

<p>Los controladores de las vistas son el nexo entre los datos y lo que se presenta al usuario. Aunque la SDK provee de una serie de controladores de vistas por defecto con una serie de comportamientos establecidos, nosotros podemos crearnos las nuestras propias.</p>

<p>Las vistas representan un area que muestra un contenido y recibe los eventos t√°ctiles. Pueden estar anidadas y animadas y desconocen qu√© hay en su entorno. Cada vista solo puede ser gestionada por un solo controlador.</p>

<h5>Controladores de contenido</h5>

<p>Presentan contenido a traveÃÅs de una vista o una jerarquiÃÅa de las mismas. Estos controladores normalmente conocen el subconjunto de datos de la aplicacioÃÅn relevantes a su papel en la aplicacioÃÅn. Si tenemos un controlador de la vista para mostrar el perfil de un usuario, el controlador de la vista conoceraÃÅ cuaÃÅles son los datos del usuario como su foto, nombre, etc.</p>

<p>Cada controlador de la vista es responsable de gestionar todas las vistas en la jerarquiÃÅa de una sola vista. Esto es que hay una correspondencia 1‚Äì1 entre el controlador y la vista. No se deberiÃÅan utilizar muÃÅltiples controladores para gestionar una sola vista ni un solo controlador para gestionar varias jerarquiÃÅas de vistas. De nuevo, la regla (en general) es utilizar un controlador por cada pantalla de la aplicacioÃÅn.</p>

<h5>Controladores Contenedores</h5>

<p>Tienen contenido que pertenece a otros controladores de vista. EÃÅstos otros controladores de vista han sido expliÃÅcitamente asignados como hijos de este controlador de vista. Un controlador de vista puede ser a su vez padre e hijo de otros controladores de vista, lo que establece a su vez una jerarquiÃÅa de controladores de vista.</p>

<p>Un controlador contenedor gestiona una jerarquiÃÅa de vistas como un controlador normal. AdemaÃÅs tambieÃÅn puede anÃÉadir las vistas de sus controladores hijo como parte de la jerarquiÃÅa de sus vistas. El controlador padre decide donde quiere poner la vista de su controlador y hijo y que tamanÃÉo tiene que tener. Por lo demaÃÅs el controlador hijo es el responsable de gestionar su propia jerarquiÃÅa de vistas.</p>

<h5>Inicializaci√≥n de un controlador de la vista</h5>

<p>Cuando alguna parte de la aplicacioÃÅn pide la vista al controlador y eÃÅsta no estaÃÅ en memoria. El controlador la carga en memoria y la almacena en su propiedad view. Los pasos que ocurren en el proceso de carga son:</p>

<ul>
<li>El controlador llama al meÃÅtodo loadView que carga la vista.</li>
<li>El controlador llama a su meÃÅtodo viewDidLoad que permite a la subclase hacer cualquier tipo de carga adicional.</li>
</ul>


<p>Ambos loadView y viewDidLoad pueden ser sobrescritos para facilitar el comportamiento deseado por el controlador.</p>

<p><img src="http://res.cloudinary.com/rafaparadela/image/upload/v1402871618/Captura_de_pantalla_2014-06-15_a_la_s_16_28_27_amxpjg.png" alt="image" /></p>

<h5>Creando vistas de forma programaÃÅtica</h5>

<p>Para ellos, tendremos que sobreescribir el meÃÅtodo loadView y en eÃÅl.
- Crear una vista raiÃÅz para el controlador.</p>

<ul>
<li>Crear vistas adicionales y anÃÉadirlas a la vista raiÃÅz.</li>
<li>Asignar la vista raiÃÅz a la propiedad view del controlador.</li>
</ul>


<p>Es importante no llamar a super loadView ya que esto lanza el
comportamiento habitual y es un malgasto de recursos.</p>

<h5>Soportando muÃÅltiples orientaciones de interfaz</h5>

<p>Gracias al aceleroÃÅmetro, las aplicaciones pueden conocer la orientacioÃÅn actual del dispositivo. Por defecto, una aplicacioÃÅn soporta orientacioÃÅn vertical y horizontal. Cuando eÃÅsta cambia, el dispositivo manda una notificacioÃÅn <code>UIDeviceOrientationDidChangeNotification</code>. Por defecto, UIKit recoge esta notificacioÃÅn y realiza los cambios pertinentes. Esto quiere decir que, excepto unas pocas excepciones, no necesitariÃÅamos hacer nada maÃÅs.</p>

<p>Cuando cambia la orientacioÃÅn, la ventana es redimensionada para encajar en la nueva orientacioÃÅn. La ventana tambieÃÅn ajusta el el frame de su controlador raiÃÅz para coincidir con el nuevo tamanÃÉo. Por tanto, la forma maÃÅs faÃÅcil de soportar muÃÅltiples orientaciones en nuestro controlador es configurar su jerarquiÃÅa de vistas para que sus subvistas se actualicen cada vez que el frame de la vista raiÃÅz cambie.</p>

<p>Si no queremos el comportamiento por defecto, podemos controlar:</p>

<ul>
<li>Las orientaciones que queremos que soporte la app.</li>
<li>Como una rotacioÃÅn entre dos orientaciones es animada en pantalla.</li>
</ul>


<p>Ejemplos:</p>

<p>Sobreescribiendo <code>supportedInterfaceOrientations</code> podemos indicar las orientaciones soportadas:</p>

<pre><code>-  (NSUInteger)supportedInterfaceOrientations{
    return (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskPortraitUpsideDown);
}
</code></pre>

<p>Evitando que se auto-rote:</p>

<pre><code>- (BOOL)shouldAutorotate
{
    return NO;
}
</code></pre>

<p>A veces tendremos un controlador cuyo contenido se vea mejor en cierta orientacioÃÅn. Aunque soporte otras orientaciones, queremos que al presentarse salga en esa. Para ello, deberemos sobreescribir el meÃÅtodo <code>preferredInterfaceOrientationForPresentation</code>. Esta orientacioÃÅn debe estar incluida en las <code>supportedInterfaceOrientations</code>:</p>

<pre><code>- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation{
    return UIInterfaceOrientationPortraitUpsideDown;
}
</code></pre>

<h5>Presentando Controladores desde otros controladores</h5>

<p>Cualquier tipo de controlador puede ser presentado por la aplicacioÃÅn. Sin embargo, solo deberiÃÅamos presentar nuevos controladores cuando queramos transmitir un significado especiÃÅfico sobre la relacioÃÅn de la jerarquiÃÅa previa y la nueva presentada.</p>

<p>Cuando presentas un controlador modal, el sistema crea una relacioÃÅn entre el controlador que hizo la presentacioÃÅn y el presentado. El controlador presentador actualiza su propiedad presentedViewController con el controlador presentado y el presentado actualiza su propiedad presentingViewController con el presentador. Pasos a seguir.</p>

<ol>
<li>Crear el controlador a presentar.</li>
<li>Establecer la propiedad modalTransitionStyle del controlador con el valor deseado.</li>
<li>Asignar un delegate al view controller. TiÃÅpicamente seraÃÅ el controlador presentador. El delegado seraÃÅ usado por el controlador presentado para informar al presentador cuando estaÃÅ listo para ser ocultado. TambieÃÅn podriÃÅa comunicar otra informacioÃÅn.</li>
<li>Llamar al meÃÅtodo presentViewController:animated:completion pasando como argumento el controlador a presentar.</li>
</ol>


<p>Un ejemplo, de un ViewController con un UIButton que al pulsar muestra otra vista con el efecto "Cover", adem√°s es delegado de ella y por tanto implementa el m√©todo para ocultar al segunda vista:</p>

<pre><code>@interface IHViewController ()&lt;IHPresentedViewControllerDelegate&gt;
@property (nonatomic, strong) UIButton *btn1;
@property (nonatomic, strong) IHPresentedViewController * myViewController;
@end

...

- (void)exercise1
{
    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 10, 200, 30);
    [self.btn1 setTitle:@"Boton1" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(transitionCover) forControlEvents:UIControlEventTouchUpInside];

}

...

- (void) transitionCover{
    self.myViewController = [[IHPresentedViewController alloc] init];
    self.myViewController.delegate = self;
    self.myViewController.modalTransitionStyle = UIModalTransitionStyleCoverVertical;
    [self presentViewController:self.myViewController animated:YES completion:nil];

    NSLog(@"cover");
}

...

- (void) dismissMe{
    [self.myViewController dismissViewControllerAnimated:YES completion:nil];
}
</code></pre>

<p>En el controlador delegado:</p>

<pre><code>- (void)viewDidLoad
{
    [super viewDidLoad];

    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 10, 200, 30);
    [self.btn1 setTitle:@"Volver" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(volverAtras) forControlEvents:UIControlEventTouchUpInside];

}

...

- (void) volverAtras{
    [self.delegate dismissMe];
}
</code></pre>

<h5>Controladores contenedores</h5>

<p>Son una parte vital del disenÃÉo de apps en iOS. Nos permiten descomponer la app en piezas maÃÅs pequenÃÉas y simples, cada una manejada por un controlador dedicado a esa tarea. Los contenedores permiten a esos controladores trabajar juntos para construir una interfaz impoluta.</p>

<p>iOS nos provee de contenedores standard como son UINavigationController o UITabBarController, sin embargo a veces necesitamos un flujo personalizado que no podemos encontrar en los controladores del sistema. Si necesitamos una organizacioÃÅn especial de controladores hijos con una navegacioÃÅn especial o transiciones animadas de un tipo en particular, tendremos que crearnos uno personalizado.</p>

<p>Ejemplo: En un ViewController, a√±adir dos UIButton, uno para a√±adir una subvista con el fondo rojo y otro para eliminarla.</p>

<pre><code>@property (nonatomic, strong) UIButton *btn1;
@property (nonatomic, strong) UIButton *btn2;
@property (nonatomic, strong) UIViewController *myViewController;

...

- (void)exercise1
{

    self.btn1 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn1.frame = CGRectMake(10, 20, 200, 30);
    [self.btn1 setTitle:@"Boton1" forState:UIControlStateNormal];
    [self.view addSubview:self.btn1];
    [self.btn1 addTarget:self action:@selector(openChild) forControlEvents:UIControlEventTouchUpInside];

    self.btn2 = [UIButton buttonWithType:UIButtonTypeSystem];
    self.btn2.frame = CGRectMake(200, 20, 200, 30);
    [self.btn2 setTitle:@"Boton2" forState:UIControlStateNormal];
    [self.view addSubview:self.btn2];
    [self.btn2 addTarget:self action:@selector(closeChild) forControlEvents:UIControlEventTouchUpInside];

    self.myViewController = [[UIViewController alloc] init];
    self.myViewController.view.frame = CGRectMake(20, 100, 100, 100);
    [self.myViewController.view setBackgroundColor: [UIColor redColor]];
}

- (void) openChild{

    [self addChildViewController:self.myViewController];
    [self.view  addSubview:self.myViewController.view];
    [self.myViewController didMoveToParentViewController:self];
    NSLog(@"Entra");
}

- (void) closeChild{
    [self.myViewController willMoveToParentViewController:nil];
    [self.myViewController.view removeFromSuperview];
    [self.myViewController removeFromParentViewController];
    NSLog(@"Sale");
}
</code></pre>

<h4>Arquitectura de Vistas</h4>

<p>Un objeto UIView define una regi√≥n rectangular de la pantalla que maneja los dibujos y loe eventos t√°ctiles en esa regi√≥n. Una vista puede tambi√©n actuar como padre para otras vistas y coordinar el lugar y el tama√±o de esas subvistas.</p>

<p>Cada vista tiene su correspondiente objeto "<em>layer</em>" que puede ser accedido con la propiedad <code>layer</code> de esa vista.</p>

<h5>Las propiedades <em>Frame</em>, <em>Bounds</em> y <em>Center</em></h5>

<p>La propiedad <strong>Frame:</strong> contiene el rect√°ngulo (tama√±o y posici√≥n) que ocupa en el sistema de cordenadas de la vista padre.</p>

<p>La propiedad <strong>Bounds:</strong> contiene el rect√°ngulo (tama√±o y posici√≥n) que ocupa el contenido en el sistema de cordenadas de la propia vista.</p>

<p>La propiedad <strong>Center:</strong> representa el punto del central de la vista en el sistema de coordenadas del padre.</p>

<p>¬øComo se crea una vista?</p>

<pre><code>ÔøºCGRect  viewRect = CGRectMake(0, 0, 100, 100);
UIView* myView = [[UIView alloc] initWithFrame:viewRect];
</code></pre>

<p>Ejemplo: Crear 3 subvistas, posicionarlas haciendo que se solapen y modificar el zIndex de alguna de ellas:</p>

<pre><code>@property (nonatomic,strong) UIView *myFirstView;
@property (nonatomic,strong) UIView *mySecondView;
@property (nonatomic,strong) UIView *myThirdView;
...
self.myFirstView = [[UIView alloc] initWithFrame:CGRectMake(30, 30, 300, 240)];
[self.myFirstView setBackgroundColor:[UIColor redColor]];
[self.view addSubview:self.myFirstView];

self.mySecondView = [[UIView alloc] initWithFrame:CGRectMake(90, 90, 300, 240)];
[self.mySecondView setBackgroundColor:[UIColor blueColor]];
[self.view addSubview:self.mySecondView];
[self.view sendSubviewToBack: self.mySecondView];

self.myThirdView = [[UIView alloc] initWithFrame:CGRectMake(60, 60, 300, 240)];
[self.myThirdView setBackgroundColor:[UIColor yellowColor]];
[self.view addSubview:self.myThirdView];
[self.view insertSubview:self.myThirdView atIndex:1];
</code></pre>

<p>Otro ejemplo. A√±adir una subvista que contenga una imagen que respete sus proporciones y rellene todo el rect√°ngulo de la vista:</p>

<pre><code>@property (nonatomic, strong) UIImageView * myFirstImageView;
...
myFirstImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"guinness"]];
[myFirstImageView setFrame:CGRectMake(400, 400, 300, 240)];
[myFirstImageView setBackgroundColor:[UIColor lightGrayColor]];
[myFirstImageView setContentMode:UIViewContentModeScaleAspectFill];
[myFirstImageView setClipsToBounds:YES];
[self.view myFirstImageView];
</code></pre>

<p>Otro ejemplo: Modifica mediante una animaci√≥n la opacidad, le ubicaci√≥n y las dimensiones de la subvista anterior:</p>

<pre><code>[UIView animateWithDuration:2.0 animations:^{
    self.myFirstImageView.alpha = 0.5;

    CGRect frame = self.myFirstImageView.frame;
    frame.origin.x=80;
    self.myFirstImageView.frame=frame;

    CGRect bounds = self.myFirstImageView.bounds;
    bounds.size.width=140;
    self.myFirstImageView.bounds=bounds;
}];
</code></pre>

<p>Otro ejemplo: Hacer que una subvista sea transparente mediante una animaci√≥n, y cuando esta acabe se vuelva a mostrar:</p>

<pre><code>[UIView animateWithDuration:1.0 animations:^{
    self.myView.alpha = 0;
} completion:^(BOOL finished) {
    self.myView.alpha = 1.0;
}];
</code></pre>

<p>Otro ejemplo: Rotar una subvista (UIImageView), controlando el √°ngulo con un UISlider:</p>

<pre><code>@property (nonatomic, strong) UIImageView * myImageView;
@property (nonatomic, strong) UISlider * rotateSlider;

...

self.rotateSlider = [[UISlider alloc] initWithFrame:CGRectMake(400, 700, 300, 40)];
[self.rotateSlider setMaximumValue:M_PI];
[self.rotateSlider setMinimumValue:0];
[self.view addSubview:self.rotateSlider];
[self.rotateSlider addTarget:self action:@selector(rotateImage:) forControlEvents:UIControlEventValueChanged];

...

- (void)rotateImage: (UISlider *) slider{
    CGAffineTransform oneTransform = CGAffineTransformMakeRotation(slider.value);
    self.myImageView.transform = CGAffineTransformConcat(oneTransform);
}
</code></pre>

<hr />

<h4>Nuevo profesor</h4>

<p>El jueves nos presentamos ante <a href="https://twitter.com/foolonhill">Ricardo Sanchez</a> y empezamos viendo los <code>UITableView</code>.</p>

<h5>UITableView</h5>

<p>Estas vistas son, con diferencia, el componente iOS m√°s popular llegando hasta el 94% de las apps, ya que pueden mostrar muchos recursos  usando muy poca memoria.</p>

<p>Las TableView se componen de:</p>

<ul>
<li><code>UITableCell</code>'s</li>
<li>Header y Footer de cada secci√≥n.</li>
<li>Header y Footer de la propia TableView</li>
<li>Datasource</li>
<li>Delegate</li>
</ul>


<h5>UITableViewCell</h5>

<p>Las celdas de una TableView pueden ser est√°ticas o din√°micas, hay diferentes estilos por defectos, pero son muy f√°cilmente customizables. Para su uso es necesario definir su "Reuse Identifier" y su posici√≥n en la tabla/secci√≥n viene definida por <code>NSIndexPath</code>.</p>

<h5>UITableViewController</h5>

<p>Son un tipo particular de UIViewController que incluyen el Delegate y Datasource de la tabla y adem√°s aportan m√°s funcionalidades.</p>

<p>El Datasource exige la implementaci√≥n de estos dos m√©todos:</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
</code></pre>

<p>Es necesario tambi√©n definir la vista UITableViewCell que se reusar√°, a trav√©s de su identificador:</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath
Ôøº
</code></pre>

<hr />

<p>Ejemplo de tabla con secciones:</p>

<p>Para este ejemplo vamos a usar un modelo, que contiene una lista de casas (Juego de Tronos) y cada casa tiene un listado de personas.</p>

<pre><code>self.model = [[GotModel alloc] init];
[self.model cargaModelo];

...


- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
    return self.model.casas.count;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    Casa *casa = [self.model.casas objectAtIndex:section];
    return casa.personajes.count;
}

- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{
    Casa *casa = [self.model.casas objectAtIndex:section];
    return casa.nombre;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"celdaPersonaje" forIndexPath:indexPath];
    Casa *casa = [self.model.casas objectAtIndex:indexPath.section];
    Personaje * personaje = [casa.personajes objectAtIndex:indexPath.row];
    cell.textLabel.text = personaje.nombre;
    cell.detailTextLabel.text = personaje.descripcion;
    return cell;
}
</code></pre>

<h3>Customize cells</h3>

<p>Para crear tu propia celda:
- Crea tu clase que extienda de UITableViewCell
- En el storyboard, indicas que la celda sea de la clase que hemos creado.
- Ponemos que sea tipo custom y le ponemos un identificador.
- Le metemos los elementos que queramos y creamos los outlet (En el .h de nuestra clase).
- Por ultimo en nuestra UITableViewController:</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    MyTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"celdaPersonaje" forIndexPath:indexPath];
    Casa *casa = [self.model.casas objectAtIndex:indexPath.section];
    Personaje * personaje = [casa.personajes objectAtIndex:indexPath.row];
    cell.myLabel.text = personaje.nombre;
    cell.myImage.image = [UIImage imageNamed:personaje.imagen];
    return cell;

}
</code></pre>

<p>Para cambiar el alto de la celda:</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{
    return 70.0;
}
</code></pre>

<h5>UITableViewDelegate</h5>

<p>Para que cuando pinche en una celda que te lleve a otra vista con info.
Y el nuevo controlador</p>

<pre><code>@property (weak, nonatomic) IBOutlet UIImageView *myImagen;
@property (weak, nonatomic) IBOutlet UITextView *myTextArea;
@property (weak, nonatomic) Personaje* myPersonaje;

...

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.

    self.myImagen.image = [UIImage imageNamed:self.myPersonaje.imagen];
    self.myTextArea.text = self.myPersonaje.descripcion;
    self.title = self.myPersonaje.nombre;
}
</code></pre>

<p>Creamo segue con un identificador <code>mySegue</code>:</p>

<pre><code>
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{
    [self performSegueWithIdentifier:@"mySegue" sender:self];
}

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{
    if([segue.identifier  isEqual: @"mySegue"]){
        MySecondViewController* mySecondView = segue.destinationViewController;

        NSInteger casaId = self.tableView.indexPathForSelectedRow.section;
        Casa * casa = [self.model.casas objectAtIndex:casaId];

        NSInteger personajeId = self.tableView.indexPathForSelectedRow.row;
        Personaje* personaje = [casa.personajes objectAtIndex:personajeId];

        mySecondView.myPersonaje = personaje;

        NSLog(@"%d", personajeId);

    }

}
</code></pre>

<p>Cambiar el header de una section:</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section{
    return 100.0;
}

- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section{
    Casa * casa = [self.model.casas objectAtIndex:section];
    UIImage *logo = [UIImage imageNamed:casa.imagen];
    UIImageView* myImageSectionView = [[UIImageView alloc] initWithImage:logo];
    return myImageSectionView;
}
</code></pre>

<h5>Borrar celdas</h5>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath
{
    if (editingStyle == UITableViewCellEditingStyleDelete) {
        NSInteger casaId = indexPath.section;
        Casa * casa = [self.model.casas objectAtIndex:casaId];
        NSInteger personajeId = indexPath.row;
        NSMutableArray* myarray = [[NSMutableArray alloc] initWithArray:casa.personajes];

        [myarray removeObjectAtIndex:personajeId];

        casa.personajes = myarray;

        [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];


    }
}
</code></pre>

<p>Si llamamos "deleteRowsAtIndexPaths" antes que se cambie el modelo, falla, la soluci√≥n es ponerlo despues en encapsular ese bloque de codigo entre:</p>

<pre><code>[self.tableView beginUpdates];
...
[self.tableView endUpdates];
</code></pre>

<h5>Mover Celdas</h5>

<p>Para mover las celdas es neceario implementar estos dos m√©todos:</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath{
    return YES;
}

- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath{

    // Aqu√≠ se implementa los cambios en el modelo.

}
</code></pre>

<!--#####A√±adir celdas
Perdido

#####Search
Lio!!!
-->


<h5>UICollectionView</h5>

<p>Son un tipo especial de UITableView que incluyen <em>Layouts</em>, inicialmente de tipo <em>grid</em>. Apple aporta un tipo de layout muy f√°cil de manejar, llamado UICollectionViewFlowLayout. Los layouts pueden ser cambiados din√°micamente.</p>

<p>Las CollectionViews se componen de:</p>

<ul>
<li>UICollectionViewCell</li>
<li>SupplementaryViews</li>
<li>DecoratorViews</li>
</ul>


<p>Veamos el uso de estos componentes con un ejemplo:</p>

<h5>Cells</h5>

<p>Para definir las celdas de nuestro <code>UICollectionView</code> de ejemplo, vamos a crear una clase "<code>CustomCell</code>" que extienda de <code>UICollectionViewCell</code> con una propiedad p√∫blica del tipo <code>UIImageView</code>. En su m√©todo inicializador le a√±adimos caracter√≠sticas a la imagen:</p>

<pre><code>self.myImage = [[UIImageView alloc] initWithFrame:self.bounds];
[self.myImage setContentMode:UIViewContentModeScaleAspectFill];
[self.myImage setClipsToBounds:YES];
[self addSubview:self.myImage];

...

- (void)layoutSubviews{
    [super layoutSubviews];
    self.myImage.frame = self.bounds;
}
</code></pre>

<p>En el <code>UICollectionViewController</code>, lo hacemos delegado de <code>&lt;UICollectionViewDataSource&gt;</code>, e implmentamos estos m√©todos:</p>

<pre><code>@property (nonatomic, strong) UICollectionView *myCollectionView;
@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayout;

...

self.modelo = [[GotModel alloc] init];
[self.modelo cargaModelo];
self.myCollectionViewLayout = [[UICollectionViewFlowLayout alloc] init];
self.myCollectionViewLayout.itemSize = CGSizeMake(350, 80);
self.myCollectionViewLayout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
self.myCollectionViewLayout.minimumInteritemSpacing = 20;
self.myCollectionViewLayout.minimumLineSpacing = 20;
self.myCollectionViewLayout.scrollDirection = UICollectionViewScrollDirectionVertical;
self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 120);
self.myCollectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:self.myCollectionViewLayout];
self.myCollectionView.dataSource = self;
self.myCollectionView.delegate = self;
[self.myCollectionView setContentInset: UIEdgeInsetsMake(64, 0, 0, 0)];
[self.myCollectionView registerClass:[CustomCell class] forCellWithReuseIdentifier:@"cellIdent"];
[self.view addSubview:self.myCollectionView];

...

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{

    CustomCell *cell = [self.myCollectionView dequeueReusableCellWithReuseIdentifier:@"cellIdent" forIndexPath:indexPath];
    Casa* casa = [self.modelo.casas objectAtIndex:indexPath.section];
    Personaje* personaje = [casa.personajes objectAtIndex:indexPath.row];
    UIImage * myCellImage =  [UIImage imageNamed:[NSString stringWithFormat:@"%@.jpg", personaje.imagen]];
    cell.myImage.image = myCellImage;
    return cell;
}

- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView{
    return self.modelo.casas.count;
}

- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{
    Casa* casa = [self.modelo.casas objectAtIndex:section];
    return casa.personajes.count;
}
</code></pre>

<h5>Header</h5>

<p>Para definir el header,</p>

<pre><code>self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 30);

....

[self.myCollectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent"];

...

- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{

    UICollectionReusableView* myHeaderView = [self.myCollectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent" forIndexPath:indexPath];

    myHeaderView.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1];

    return myHeaderView;
}
</code></pre>

<h5>Lo vamos a hacer pero con una subclase</h5>

<ul>
<li>Creamos una clase de UICollectionReusableView (llamada por ejemplo CustomHeader)con un propiedad publica label:</li>
</ul>


<pre><code>@interface CustomHeader : UICollectionReusableView

@property (strong, nonatomic) UILabel * myLabel;

@end
</code></pre>

<p>Inicializamos el label;</p>

<pre><code>self.myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, self.frame.size.width, self.frame.size.height)];
self.myLabel.text = @"Hola";
[self.myLabel setTextAlignment:NSTextAlignmentCenter];
[self.myLabel setFont:[UIFont fontWithName:@"Helvetica" size:30.0]];
self.myLabel.textColor = [UIColor lightGrayColor];
[self addSubview:self.myLabel];
</code></pre>

<p> En el controlador principal:</p>

<pre><code>#import "CustomHeader.h"

...

- (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{

    CustomHeader* myHeaderView = [self.myCollectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"headerIdent" forIndexPath:indexPath];

    myHeaderView.backgroundColor = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1];

    Casa* casa = [self.modelo.casas objectAtIndex:indexPath.section];

    myHeaderView.myLabel.text = casa.nombre;

    return myHeaderView;
}
</code></pre>

<h5>A√±adir segment control para elegir vertical u horizontal</h5>

<ul>
<li>Creamos un segmen control, con storyboard y metemos IBoutlet y IBaction</li>
<li>Creamos dos layouts:</li>
</ul>


<pre><code>@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayout;
@property (nonatomic, strong) UICollectionViewFlowLayout * myCollectionViewLayoutHorizontal;
</code></pre>

<p>Implementamos los cambios:</p>

<pre><code>    self.myCollectionViewLayout = [[UICollectionViewFlowLayout alloc] init];
    self.myCollectionViewLayout.itemSize = CGSizeMake(100, 100);
    self.myCollectionViewLayout.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
    self.myCollectionViewLayout.minimumInteritemSpacing = 20;
    self.myCollectionViewLayout.minimumLineSpacing = 20;
    self.myCollectionViewLayout.scrollDirection = UICollectionViewScrollDirectionVertical;
    self.myCollectionViewLayout.headerReferenceSize = CGSizeMake(self.myCollectionView.frame.size.width, 120);

    self.myCollectionViewLayoutHorizontal = [[UICollectionViewFlowLayout alloc] init];
    self.myCollectionViewLayoutHorizontal.itemSize = CGSizeMake(140, 140);
    self.myCollectionViewLayoutHorizontal.sectionInset = UIEdgeInsetsMake(20, 20, 20, 20);
    self.myCollectionViewLayoutHorizontal.minimumInteritemSpacing = 20;
    self.myCollectionViewLayoutHorizontal.minimumLineSpacing = 20;
    self.myCollectionViewLayoutHorizontal.scrollDirection = UICollectionViewScrollDirectionHorizontal;
    self.myCollectionViewLayoutHorizontal.headerReferenceSize = CGSizeMake(120,self.myCollectionView.frame.size.height);
</code></pre>

<p>En el ibaction del segmentcontrol controlo el valor:</p>

<pre><code>- (IBAction)selectSegment:(id)sender {
    UISegmentedControl * segment = sender;

    if(segment.selectedSegmentIndex==0){
        [self.myCollectionView setCollectionViewLayout:self.myCollectionViewLayout animated:YES];
    }
    else{
        [self.myCollectionView setCollectionViewLayout:self.myCollectionViewLayoutHorizontal animated:YES];
    }

}
</code></pre>

<h5>CollectionView Delegate: Seleccionar varios elementos para elimiarlos</h5>

<p>Permitir el multiple selection:</p>

<pre><code>self.myCollectionView.allowsMultipleSelection = YES;
</code></pre>

<p>Para cambiar el estilo de la celda seleccionada, implemento el cambio en su clase</p>

<pre><code>- (void)setSelected:(BOOL)selected{
    [super setSelected:selected];

    if (selected) {
        [self.myImage setAlpha:0.5];
    }
    else{
        [self.myImage setAlpha:1.0];
    }
}
</code></pre>

<p>Creamos un IBAction del bot√≥n de borrar con este m√©todo:</p>

<pre><code>- (IBAction)delete:(UIBarButtonItem *)sender {
    [self.myCollectionView performBatchUpdates:^{

        [self.myCollectionView deleteItemsAtIndexPaths: self.selectedItems ];

        for (int c = 0; c &lt; self.modelo.casas.count; c++) {

            NSMutableIndexSet* indexSet = [[NSMutableIndexSet alloc] init];

            for(NSIndexPath * myIndexPath in self.selectedItems){
                if(myIndexPath.section == c){
                    NSLog(@"Entro");
                    [indexSet addIndex:myIndexPath.row];
                }

            }
            Casa* casa = [self.modelo.casas objectAtIndex:c];
            NSMutableArray* newList = casa.personajes.mutableCopy;
            [newList removeObjectsAtIndexes:indexSet];
            casa.personajes = newList.copy;
        }
        [self.selectedItems removeAllObjects];

    } completion:^(BOOL finished) {

    }];

}
</code></pre>

<hr />

<p>No estuve presente en el √∫ltimo ejercicio de la semana. Queda pendiente.</p>


				  
				  <!-- %%%%%% -->

			  </div>
			  
			  <div class="bs-docs-section" id="w03-section">
				  <h1 id="w03" class="page-header">Semana 3</h1>
				  
				  <!-- &&&&&& -->
				  

<p>Victor Baro: http://victorbaro.com/ nos cuenta sus apps</p>

<p>Despues de transparencias le damos forma al proyecto donde meteremos los ejemplos. La idea es dividir los ejercicios en tres categor√≠as (Views, Drawing y Layers), con tres "Storyboards", que cargaremos desde</p>

<ul>
<li><p>Creamos un proyecto "Single View".</p></li>
<li><p>En el Storyboard principal ponemos 3 botones que le asociamos 3 IBAction en el .m del controlador, que dejaremos vac√≠o de momento:</p></li>
</ul>


<pre><code>- (IBAction)GoViews:(id)sender {

}

- (IBAction)GoDrawing:(id)sender {

}


- (IBAction)GoLayers:(id)sender {

}
</code></pre>

<ul>
<li><p>Por otra parte, creamos el storyboard para la secci√≥n "Views" y lo metemos en otra carpeta.</p></li>
<li><p>Ah√≠ en esa carpeta vamos a englobar todos los ejercicios relacionados con las Vistas. Creamos un NavigationController con un TableView (con celdas est√°ticas) y le asociamos un TableViewController, en dicha tabla vamos a listar los ejercicios, que abriremos al pulsar sobre cada celda.</p></li>
<li>Tambien creamos otro viewController gen√©rico con una propiedad llamada <code>exampleNumber</code> donde desplegaremos los diferentes ejemplos de <em>Vistas</em>.</li>
<li>A cada celda, le creamos un segue apuntando a la vista gen√©rica.</li>
<li>En el TableViewController lo preparamos para los segues:</li>
</ul>


<pre><code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{
    NSIndexPath * index = [self.tableView indexPathForCell:sender];
    GenericViewController * vc = [segue destinationViewController];
    vc.exampleNumber = index.row;
    vc.title = [sender textLabel].text;

}
</code></pre>

<ul>
<li>Para indicar qu√© ejemplo tiene que mostrar:</li>
</ul>


<pre><code>@property (nonatomic) NSUInteger exampleNumber;

...

- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view.

    switch (self.exampleNumber) {
        case 0:
            [self example01];
            break;
        case 1:
            [self example02];
            break;
        case 2:
            [self example03];
            break;

        ...


        default:
            break;
    }



}
</code></pre>

<p>Ya solo queda ir implementando los ejercicios.</p>

<h2>Ejercicios con Vista:</h2>

<h4>Entendiendo CGRectInset</h4>

<p>http://cl.ly/W53w</p>

<pre><code>- (void) example01{
    CGRect blueViewFrame = CGRectMake(100, 100, 100, 200);
    UIView *blueView = [[UIView alloc] initWithFrame:blueViewFrame];
    blueView.backgroundColor = [UIColor blueColor];
    [self.view addSubview:blueView];

    CGRect greenViewFrame = CGRectInset(blueView.bounds, 10, 10);
    UIView *greenView = [[UIView alloc] initWithFrame:greenViewFrame];
    greenView.backgroundColor = [UIColor greenColor];
    [blueView addSubview:greenView];

}
</code></pre>

<p><img src="http://f.cl.ly/items/1K2W1J3E0l030j3f2L21/Image%202014-06-16%20at%2011.56.01%20a.m..png" alt="image" /></p>

<h4>Entendiendo CGRectUnion</h4>

<pre><code>// CGRectUnion
CGRect frame1 = CGRectMake(80.0, 100.0, 150.0, 240.0);
CGRect frame2 = CGRectMake(140.0, 240.0, 120.0, 120.0);
CGRect frame3 = CGRectUnion(frame1, frame2);
UIView *view1 = [[UIView alloc] initWithFrame:frame1];
[view1 setBackgroundColor:[UIColor redColor]];
UIView *view2 = [[UIView alloc] initWithFrame:frame2];
[view2 setBackgroundColor:[UIColor orangeColor]];
UIView *view3 = [[UIView alloc] initWithFrame:frame3];
[view3 setBackgroundColor:[UIColor grayColor]];
[self.view addSubview:view3];
[self.view addSubview:view2];
[self.view addSubview:view1];
</code></pre>

<p><img src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-3.jpg" alt="image" /></p>

<h4>Entendiendo CGRectDivide</h4>

<pre><code>// CGRectDivide
CGRect frame = CGRectMake(10.0, 50.0, 300.0, 300.0);
CGRect part1;
CGRect part2;
CGRectDivide(frame, &amp;part1, &amp;part2, 100.0, CGRectMaxYEdge);

UIView *view1 = [[UIView alloc] initWithFrame:frame];
[view1 setBackgroundColor:[UIColor grayColor]];

UIView *view2 = [[UIView alloc] initWithFrame:part1];
[view2 setBackgroundColor:[UIColor orangeColor]];

UIView *view3 = [[UIView alloc] initWithFrame:part2];
[view3 setBackgroundColor:[UIColor redColor]];

[self.view addSubview:view1];
[self.view addSubview:view2];
[self.view addSubview:view3];
</code></pre>

<p><img src="https://s3.amazonaws.com/cms-assets.tutsplus.com/uploads/users/41/posts/21196/image/figure-4.jpg" alt="image" /></p>

<h4>Transforms</h4>

<pre><code>view.transform = CGAffineTransformTranslate(CGAffineTransformIdentity, 2.0, 2.0);

view.transform = CGAffineTransformMakeTranslation(2.0, 2.0);
</code></pre>

<p>La difrenecia es que la segunda transforma la ya transformada vista, para anidar animaciones.</p>

<p>Mediante la matriz:</p>

<pre><code>struct CGAffineTransform {!
   CGFloat a;!
   CGFloat b;!
   CGFloat c;!
   CGFloat d;!
   CGFloat tx;!
   CGFloat ty;!
};

new x position = old x position * a + old y position * c + tx!
new y position = old x position*b + old y position * d + ty
</code></pre>

<p>Un ejemplo: http://cl.ly/W5lx</p>

<pre><code>- (void) example03{
    CGRect blueViewFrame = CGRectMake(100, 100, 100, 100);
    UIView *blueView = [[UIView alloc] initWithFrame:blueViewFrame];
    blueView.backgroundColor = [UIColor blueColor];
    [self.view addSubview:blueView];
    blueView.transform = CGAffineTransformMake(1, 0, -0.4, 1, 0, 0);
}
</code></pre>

<h4>Custom buttons</h4>

<p>Cocoa Pods: UIColor + FlatColors
Creamos clase con esta interfaz:</p>

<pre><code>@interface MyButton : UIView

@property (nonatomic, copy) NSString *title;

- (id) initWithFrame:(CGRect)frame title:(NSString *) theTitle color:(UIColor *) fillColor;

@end
</code></pre>

<p>En la implementaci√≥n:</p>

<pre><code>@property (nonatomic, strong) UIView * shadow;
...

- (id)initWithFrame:(CGRect)frame
{
    return [self initWithFrame:frame title:@"Button" color:[UIColor greenColor]];
}

- (id) initWithFrame:(CGRect)frame title:(NSString *) theTitle color:(UIColor *) fillColor{
    self = [super initWithFrame:frame];
    if(self){
        _title = theTitle;
        self.backgroundColor = fillColor;
        [self setup];
    }
    return self;
}


- (void) setup{
    UILabel *buttonTitle = [[UILabel alloc] initWithFrame:CGRectInset(self.bounds, 10, 10)];
    buttonTitle.text = self.title;
    buttonTitle.textColor = [UIColor whiteColor];
    buttonTitle.textAlignment = NSTextAlignmentCenter;
    [self addSubview:buttonTitle];

    CGFloat shadowHeight = 5;
    self.shadow = [[UIView alloc] initWithFrame:CGRectMake(0, self.bounds.size.height - shadowHeight, self.bounds.size.width, shadowHeight)];
    self.shadow.backgroundColor = [UIColor blackColor];
    self.shadow.alpha = 0.2;
    [self addSubview:self.shadow];

}
</code></pre>

<p>En el controlador principal creamos una instancia:</p>

<pre><code>#import "MyButton.h"

...

-(void) example04{
    MyButton * myButton = [[MyButton alloc] initWithFrame:CGRectMake(20, 100, 240, 40) title:@"My Button 1" color:[UIColor colorWithRed:0.412 green:0.156 blue:0.350 alpha:1.000]];
    [self.view addSubview:myButton];
}
</code></pre>

<p><img src="http://f.cl.ly/items/2S3l0v3Y1r2B061g1Y17/Image%202014-06-16%20at%201.09.17%20p.m..png" alt="image" /></p>

<p>Para que responda a gestos, en el controllador de mi MyButton:</p>

<pre><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    self.shadow.frame = self.bounds;
    NSLog(@"Tocado");
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{
    CGFloat shadowHeight = 5;
    self.shadow.frame = CGRectMake(0, self.bounds.size.height - shadowHeight, self.bounds.size.width, shadowHeight);
}
</code></pre>

<h4>Gestos Multit√°ctiles</h4>

<p>Creamos una clase UIView:</p>

<pre><code>- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        [self setMultipleTouchEnabled:YES];
    }
    return self;
}

...

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    //Borramos lo que ya haya
    for (UIView *view in [self subviews]) {
        [view removeFromSuperview];
    }

    [touches enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
        UITouch *touch = obj;
        CGPoint touchPoint = [touch locationInView:self];

        UIView *touchView = [[UIView alloc] init];
        [touchView setBackgroundColor:[UIColor redColor]];
        touchView.frame = CGRectMake(touchPoint.x, touchPoint.y, 30, 30);
        [self addSubview:touchView];
    }];

}
</code></pre>

<h4>Drag</h4>

<p>Creamos otra clase como antes, pero en el touchesBegan solo lo habilitamos para toques con un solo dedo, y creamos una nueva vista siempre y cuando no coincida con una ya creada:</p>

<pre><code>@property (nonatomic, strong) UIView * dragView;

...

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {

        [self setMultipleTouchEnabled:YES];
    }
    return self;
}

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    if([touches count] == 1){
        UITouch *touch = [touches anyObject];
        CGPoint touchPoint = [touch locationInView:self];

        for(UIView * view in [self subviews]){
            if(CGRectContainsPoint(view.frame, touchPoint)){
                self.dragView = view;
                return;
            }
        }

        UIView *touchView = [[UIView alloc] init];
        [touchView setBackgroundColor:[UIColor redColor]];
        CGFloat size = 60;
        touchView.frame = CGRectMake(touchPoint.x - size/2, touchPoint.y - size/2, size, size);
        [self addSubview:touchView];
        self.dragView = touchView;

    }


}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    self.dragView.center = [touch locationInView:self];
}

- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    self.dragView.center = [touch locationInView:self];
}
</code></pre>

<h2>Autolayout:</h2>

<p>Todo lo que necesitas saber de autolayouts <a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">aqu√≠</a>.</p>

<p>Cuando queremos animar una vista cuyas dimensiones vienen definidas por <em>contrains</em>, hay que hacer las animaciones sobre esas <em>contrains</em>.</p>

<p>Vamos a ver la manipulaci√≥n de <em>contrains</em> por c√≥digo.</p>

<p>Ejemplo, a√±adir un label a 100 punto de altura:</p>

<pre><code>- (void) addLabels{
    UILabel * myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)];
    myLabel.text = @"This is my label";
    myLabel.font = [UIFont systemFontOfSize:18];
    myLabel.backgroundColor = [UIColor lightGrayColor];
    myLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:myLabel];

    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-offsetTop-[myLabel]" options:0 metrics:@{@"offsetTop": @100} views:NSDictionaryOfVariableBindings(myLabel)]];
}
</code></pre>

<p>Un label centrado respecto al padre:</p>

<pre><code>- (void) addLabels{
    UILabel * myLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 30)];
    myLabel.text = @"This is my label";
    myLabel.font = [UIFont systemFontOfSize:18];
    myLabel.backgroundColor = [UIColor lightGrayColor];
    myLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:myLabel];

    NSLayoutConstraint * unaConstrain = [NSLayoutConstraint constraintWithItem:myLabel
                                                                     attribute:NSLayoutAttributeCenterX
                                                                     relatedBy:NSLayoutRelationEqual
                                                                        toItem:self.view
                                                                     attribute:NSLayoutAttributeCenterX
                                                                    multiplier:1
                                                                      constant:0];

    [self.view addConstraint: unaConstrain];

}
</code></pre>

<p>Animando una constrain:</p>

<pre><code>@property (nonatomic, strong) NSLayoutConstraint * myConstrain;

...

- (IBAction)anima:(id)sender {

    self.myConstrain = [NSLayoutConstraint constraintWithItem:self.myLabel
                                                    attribute:NSLayoutAttributeTop
                                                    relatedBy:NSLayoutRelationEqual
                                                       toItem:self.view
                                                    attribute:NSLayoutAttributeTop
                                                   multiplier:1
                                                     constant:150];

    [self.view addConstraint: self.myConstrain];

    [UIView animateWithDuration:0.5 animations:^{
        self.myConstrain.constant = 300;
        [self.view layoutIfNeeded];
    }];

}
</code></pre>
				  
				  <!-- %%%%%% -->
			  </div>
			  
			  
			  
			  
			  
			  <!-- 
			  <div class="bs-docs-section" id="w00-section">
				  <h1 id="w00" class="page-header">Semana 00</h1>
				  
				  <!-- &&&&&& ->
				  
				  <!-- %%%%%% ->
			  </div>
			  -->

        </div>
        
      </div>

    </div>

    <!-- Footer
================================================== -->
<footer class="bs-docs-footer" role="contentinfo">
  <div class="container">
    <p>Built with all the love in the world by <a href="https://github.com/rafaparadela" target="_blank">Rafa Paradela</a>.</p>
    <p>Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
  </div>
</footer>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="assets/jquery.min.js"></script>
<script src="assets/bootstrap.min.js"></script>
<script src="assets/docs.min.js"></script>
<script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




  </body>
</html>
